{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CNOI Problem Archive \u00b6 This is an online archive of English statements of Chinese OI problems. You can find most of the files mentioned in this site (statements in Chinese, extra samples, etc.) in the repository . If you find some of my translation vague, you can look up the Chinese statement and use Google translate. Sorry if my poor English does make you confused. By the way, anyone is welcomed to contribute translations or help to correct the mistakes.","title":"Home"},{"location":"#cnoi-problem-archive","text":"This is an online archive of English statements of Chinese OI problems. You can find most of the files mentioned in this site (statements in Chinese, extra samples, etc.) in the repository . If you find some of my translation vague, you can look up the Chinese statement and use Google translate. Sorry if my poor English does make you confused. By the way, anyone is welcomed to contribute translations or help to correct the mistakes.","title":"CNOI Problem Archive"},{"location":"about/","text":"A brief introduction to the contests mentioned in this site will be added here in the future.","title":"About the Contests"},{"location":"NOI/2018/Day1-A/","text":"Coming Soon...","title":"Day 1, Task A"},{"location":"NOI/2019/Day1-A/","text":"Time limit per test : \\texttt{1 s} \\texttt{1 s} Memory limit per test : \\texttt{512 MB} \\texttt{512 MB} You can submit this problem at: LibreOJ Input : route.in Output : route.out Luogu Memory limit is changed to 128 MB here UOJ Description \u00b6 There are n n railway stations in the Kingdom of Cat, numbered from 1 1 to n n . Little cat is going home (at station n n ) from station 1 1 . There are m m trains in the kingdom, numbered from 1 1 to m m . For the i i -th train, it will depart station x_i x_i at time p_i p_i , and arrive at station station y_i y_i directly at time q_i q_i . At time 0 0 , little cat is at station 1 1 . Little cat can go home by multiple transfers. One transfer is that for a pair of trains u u and v v , if y_u = x_v y_u = x_v and q_u \\leq p_v q_u \\leq p_v , then after taking train u u , little cat can wait at station y_u y_u for p_v - q_u p_v - q_u time units, and take train v v at time p_v p_v . Little cat wants to minimize its anxiety , which is calculated as followed: If little cat waits at some stations for t\\,(t \\geq 0) t\\,(t \\geq 0) time units, its anxiety will be increased by At^2 + Bt + C At^2 + Bt + C , where A, B, C A, B, C are given constants. Note that before little cat taking the first train at time t t , it has been waiting for t t time units at station 1 1 . If little cat arrives at station n n at time z z , its anxiety will be increased by z z . Formally, if little cat takes k k trains totally, whose numbers are s_1, s_2, \\cdots, s_k s_1, s_2, \\cdots, s_k , little cat can get home if and only if: x_{s_1} = 1, y_{s_k} = n x_{s_1} = 1, y_{s_k} = n y_{s_j} = x_{s_{j + 1}} y_{s_j} = x_{s_{j + 1}} and q_{s_j} \\leq p_{s_{j + 1}} q_{s_j} \\leq p_{s_{j + 1}} hold for 1 \\leq j < k 1 \\leq j < k and its anxiety will be $$ q_{s_k} + (A \\cdot p_{s_1}^2 + B \\cdot p_{s_1} + C) + \\sum_{j = 1}^{k - 1}\\left(A(p_{s_{j + 1}} - q_{s_j})^2 + B(p_{s_{j + 1}} - q_{s_j}) + C\\right) $$ Your task is to figure out the minimal anxiety. Input \u00b6 The first line contains 5 5 integers n, m, A, B, C n, m, A, B, C . Each of the next m m lines contains 4 4 integers p_i, q_i, x_i, y_i p_i, q_i, x_i, y_i . It is guaranteed that there is at least one way for little cat to go home. Output \u00b6 Print a single integer \u2014 the minimal anxiety. Samples \u00b6 Sample 1 \u00b6 Input \u00b6 3 4 1 5 10 1 2 3 4 1 2 5 7 1 2 6 8 2 3 9 10 Output \u00b6 94 Explanation \u00b6 There are 3 3 ways to go home. Take train 1, 4 1, 4 in turn, and the anxiety is 10 + 1 \\times 3^2 + 5 \\times 3 + 10 + 1 \\times (9-4)^2 + 5 \\times (9-4) + 10 = 104 10 + 1 \\times 3^2 + 5 \\times 3 + 10 + 1 \\times (9-4)^2 + 5 \\times (9-4) + 10 = 104 Take train 2, 4 2, 4 in turn, and the anxiety is 10 + 1 \\times 5^2 + 5 \\times 5 + 10 + 1 \\times (9-7)^2 + 5 \\times (9-7) + 10 = 94 10 + 1 \\times 5^2 + 5 \\times 5 + 10 + 1 \\times (9-7)^2 + 5 \\times (9-7) + 10 = 94 Take train 3, 4 3, 4 in turn, and the anxiety is 10 + 1 \\times 6^2 + 5 \\times 6 + 10 + 1 \\times (9-8)^2 + 5 \\times (9-8) + 10 = 102 10 + 1 \\times 6^2 + 5 \\times 6 + 10 + 1 \\times (9-8)^2 + 5 \\times (9-8) + 10 = 102 So the minimal anxiety is 94 94 . Sample 2 \u00b6 Input \u00b6 4 3 1 2 3 1 2 2 3 2 3 5 7 3 4 7 9 Output \u00b6 34 Constraints \u00b6 For all of the tests, 2 \\leq n \\leq 10^5 2 \\leq n \\leq 10^5 , 1 \\leq m \\leq 2 \\times 10^5 1 \\leq m \\leq 2 \\times 10^5 , 0 \\leq A \\leq 10 0 \\leq A \\leq 10 , 0 \\leq B, C \\leq 10^6 0 \\leq B, C \\leq 10^6 , 1 \\leq x_i, y_i \\leq n 1 \\leq x_i, y_i \\leq n , x_i \\neq y_i x_i \\neq y_i , 0 \\leq p_i < q_i \\leq 10^3 0 \\leq p_i < q_i \\leq 10^3 . For partial scores, you can look up at the origin statement ( NOI/2019/Day1.pdf ).","title":"Day 1, Task A"},{"location":"NOI/2019/Day1-A/#description","text":"There are n n railway stations in the Kingdom of Cat, numbered from 1 1 to n n . Little cat is going home (at station n n ) from station 1 1 . There are m m trains in the kingdom, numbered from 1 1 to m m . For the i i -th train, it will depart station x_i x_i at time p_i p_i , and arrive at station station y_i y_i directly at time q_i q_i . At time 0 0 , little cat is at station 1 1 . Little cat can go home by multiple transfers. One transfer is that for a pair of trains u u and v v , if y_u = x_v y_u = x_v and q_u \\leq p_v q_u \\leq p_v , then after taking train u u , little cat can wait at station y_u y_u for p_v - q_u p_v - q_u time units, and take train v v at time p_v p_v . Little cat wants to minimize its anxiety , which is calculated as followed: If little cat waits at some stations for t\\,(t \\geq 0) t\\,(t \\geq 0) time units, its anxiety will be increased by At^2 + Bt + C At^2 + Bt + C , where A, B, C A, B, C are given constants. Note that before little cat taking the first train at time t t , it has been waiting for t t time units at station 1 1 . If little cat arrives at station n n at time z z , its anxiety will be increased by z z . Formally, if little cat takes k k trains totally, whose numbers are s_1, s_2, \\cdots, s_k s_1, s_2, \\cdots, s_k , little cat can get home if and only if: x_{s_1} = 1, y_{s_k} = n x_{s_1} = 1, y_{s_k} = n y_{s_j} = x_{s_{j + 1}} y_{s_j} = x_{s_{j + 1}} and q_{s_j} \\leq p_{s_{j + 1}} q_{s_j} \\leq p_{s_{j + 1}} hold for 1 \\leq j < k 1 \\leq j < k and its anxiety will be $$ q_{s_k} + (A \\cdot p_{s_1}^2 + B \\cdot p_{s_1} + C) + \\sum_{j = 1}^{k - 1}\\left(A(p_{s_{j + 1}} - q_{s_j})^2 + B(p_{s_{j + 1}} - q_{s_j}) + C\\right) $$ Your task is to figure out the minimal anxiety.","title":"Description"},{"location":"NOI/2019/Day1-A/#input","text":"The first line contains 5 5 integers n, m, A, B, C n, m, A, B, C . Each of the next m m lines contains 4 4 integers p_i, q_i, x_i, y_i p_i, q_i, x_i, y_i . It is guaranteed that there is at least one way for little cat to go home.","title":"Input"},{"location":"NOI/2019/Day1-A/#output","text":"Print a single integer \u2014 the minimal anxiety.","title":"Output"},{"location":"NOI/2019/Day1-A/#samples","text":"","title":"Samples"},{"location":"NOI/2019/Day1-A/#sample-1","text":"","title":"Sample 1"},{"location":"NOI/2019/Day1-A/#input_1","text":"3 4 1 5 10 1 2 3 4 1 2 5 7 1 2 6 8 2 3 9 10","title":"Input"},{"location":"NOI/2019/Day1-A/#output_1","text":"94","title":"Output"},{"location":"NOI/2019/Day1-A/#explanation","text":"There are 3 3 ways to go home. Take train 1, 4 1, 4 in turn, and the anxiety is 10 + 1 \\times 3^2 + 5 \\times 3 + 10 + 1 \\times (9-4)^2 + 5 \\times (9-4) + 10 = 104 10 + 1 \\times 3^2 + 5 \\times 3 + 10 + 1 \\times (9-4)^2 + 5 \\times (9-4) + 10 = 104 Take train 2, 4 2, 4 in turn, and the anxiety is 10 + 1 \\times 5^2 + 5 \\times 5 + 10 + 1 \\times (9-7)^2 + 5 \\times (9-7) + 10 = 94 10 + 1 \\times 5^2 + 5 \\times 5 + 10 + 1 \\times (9-7)^2 + 5 \\times (9-7) + 10 = 94 Take train 3, 4 3, 4 in turn, and the anxiety is 10 + 1 \\times 6^2 + 5 \\times 6 + 10 + 1 \\times (9-8)^2 + 5 \\times (9-8) + 10 = 102 10 + 1 \\times 6^2 + 5 \\times 6 + 10 + 1 \\times (9-8)^2 + 5 \\times (9-8) + 10 = 102 So the minimal anxiety is 94 94 .","title":"Explanation"},{"location":"NOI/2019/Day1-A/#sample-2","text":"","title":"Sample 2"},{"location":"NOI/2019/Day1-A/#input_2","text":"4 3 1 2 3 1 2 2 3 2 3 5 7 3 4 7 9","title":"Input"},{"location":"NOI/2019/Day1-A/#output_2","text":"34","title":"Output"},{"location":"NOI/2019/Day1-A/#constraints","text":"For all of the tests, 2 \\leq n \\leq 10^5 2 \\leq n \\leq 10^5 , 1 \\leq m \\leq 2 \\times 10^5 1 \\leq m \\leq 2 \\times 10^5 , 0 \\leq A \\leq 10 0 \\leq A \\leq 10 , 0 \\leq B, C \\leq 10^6 0 \\leq B, C \\leq 10^6 , 1 \\leq x_i, y_i \\leq n 1 \\leq x_i, y_i \\leq n , x_i \\neq y_i x_i \\neq y_i , 0 \\leq p_i < q_i \\leq 10^3 0 \\leq p_i < q_i \\leq 10^3 . For partial scores, you can look up at the origin statement ( NOI/2019/Day1.pdf ).","title":"Constraints"},{"location":"NOI/2019/Day1-B/","text":"Time limit per test : \\texttt{3 s} \\texttt{3 s} Memory limit per test : \\texttt{512 MB} \\texttt{512 MB} You can submit this problem at: LibreOJ Input : robot.in Output : robot.out Luogu UOJ Description \u00b6 Recently, Bob invented 2 2 kinds of robots: type P and type Q. Now he wants to test the mobility of these two robots. There are n n pillars arranged in a row, numbered from 1 1 to n n . The i i -th pillar has a height of h_i h_i . The robots can only move between adjacent pillars, that is, if the robot is currently on the i i -th pillar. it can only move to the (i-1) (i-1) -th or (i+1) (i+1) -th pillar. In each test, Bob will choose a number s\\,(1 \\leq s \\leq n) s\\,(1 \\leq s \\leq n) , and put the robots on the s s -th pillar. Then the robots will move according to their own rules. Robots of type P will always move to the left , but it can't move to the pillars that are higher than pillar s s . Formally, it will stop at pllar l\\,(l \\leq s) l\\,(l \\leq s) if and only if: l = 1 l = 1 or h_{l-1} > h_s h_{l-1} > h_s h_j \\leq h_s h_j \\leq h_s holds for all l \\leq j \\leq s l \\leq j \\leq s Robots of type Q will always move to the right , but it can only move to the pillars that are shorter than pillar s s . Formally, it will stop at pllar r\\,(r \\leq s) r\\,(r \\leq s) if and only if: r = n r = n or h_{r+1} \\geq h_s h_{r+1} \\geq h_s h_j < h_s h_j < h_s holds for all s < j \\leq r s < j \\leq r Bob can set the height of all the pillars, the height of the i i -th pillar can be any integer in range [A_i, B_i] [A_i, B_i] . He wants to know how many possible ways are there to set the heights so that no matter which number s s is, the difference between the number of pillars that the robots pass by is not greater than 2 2 . Since the answer could be very large, you should print the answer module 10^9 + 7 10^9 + 7 instead. Input \u00b6 The first line contains a single integer n n . Each of the next n n lines contains twp integers A_i, B_i A_i, B_i . Output \u00b6 Print a single integer \u2014 the answer module 10^9 + 7 10^9 + 7 . Samples \u00b6 Sample 1 \u00b6 Input \u00b6 5 3 3 2 2 3 4 2 2 3 3 Note : In Chinese statement, the sample input isn't printed correctly. Output \u00b6 1 Explanation \u00b6 There are two possible ways to set the heights: If the heights are 3\\,2\\,3\\,2\\,3 3\\,2\\,3\\,2\\,3 respectively. When s = 5 s = 5 , we can see that Robot of type P will stop at pillar 1 1 (pass by 4 4 pillars in total) and robot of type Q will stop at pillar 5 5 (pass by 0 0 pillars in total), which breaks the condition. If the heights are 3\\,2\\,4\\,2\\,3 3\\,2\\,4\\,2\\,3 respectively. We can show that no matter which number s s is, the condition is always satisfied. Constraints \u00b6 For all of the tests, 1 \\leq n \\leq 300 1 \\leq n \\leq 300 , 1 \\leq A_i \\leq B_i \\leq 10^9 1 \\leq A_i \\leq B_i \\leq 10^9 . For partial scores, you can look up at the origin statement ( NOI/2019/Day1.pdf ).","title":"Day 1, Task B"},{"location":"NOI/2019/Day1-B/#description","text":"Recently, Bob invented 2 2 kinds of robots: type P and type Q. Now he wants to test the mobility of these two robots. There are n n pillars arranged in a row, numbered from 1 1 to n n . The i i -th pillar has a height of h_i h_i . The robots can only move between adjacent pillars, that is, if the robot is currently on the i i -th pillar. it can only move to the (i-1) (i-1) -th or (i+1) (i+1) -th pillar. In each test, Bob will choose a number s\\,(1 \\leq s \\leq n) s\\,(1 \\leq s \\leq n) , and put the robots on the s s -th pillar. Then the robots will move according to their own rules. Robots of type P will always move to the left , but it can't move to the pillars that are higher than pillar s s . Formally, it will stop at pllar l\\,(l \\leq s) l\\,(l \\leq s) if and only if: l = 1 l = 1 or h_{l-1} > h_s h_{l-1} > h_s h_j \\leq h_s h_j \\leq h_s holds for all l \\leq j \\leq s l \\leq j \\leq s Robots of type Q will always move to the right , but it can only move to the pillars that are shorter than pillar s s . Formally, it will stop at pllar r\\,(r \\leq s) r\\,(r \\leq s) if and only if: r = n r = n or h_{r+1} \\geq h_s h_{r+1} \\geq h_s h_j < h_s h_j < h_s holds for all s < j \\leq r s < j \\leq r Bob can set the height of all the pillars, the height of the i i -th pillar can be any integer in range [A_i, B_i] [A_i, B_i] . He wants to know how many possible ways are there to set the heights so that no matter which number s s is, the difference between the number of pillars that the robots pass by is not greater than 2 2 . Since the answer could be very large, you should print the answer module 10^9 + 7 10^9 + 7 instead.","title":"Description"},{"location":"NOI/2019/Day1-B/#input","text":"The first line contains a single integer n n . Each of the next n n lines contains twp integers A_i, B_i A_i, B_i .","title":"Input"},{"location":"NOI/2019/Day1-B/#output","text":"Print a single integer \u2014 the answer module 10^9 + 7 10^9 + 7 .","title":"Output"},{"location":"NOI/2019/Day1-B/#samples","text":"","title":"Samples"},{"location":"NOI/2019/Day1-B/#sample-1","text":"","title":"Sample 1"},{"location":"NOI/2019/Day1-B/#input_1","text":"5 3 3 2 2 3 4 2 2 3 3 Note : In Chinese statement, the sample input isn't printed correctly.","title":"Input"},{"location":"NOI/2019/Day1-B/#output_1","text":"1","title":"Output"},{"location":"NOI/2019/Day1-B/#explanation","text":"There are two possible ways to set the heights: If the heights are 3\\,2\\,3\\,2\\,3 3\\,2\\,3\\,2\\,3 respectively. When s = 5 s = 5 , we can see that Robot of type P will stop at pillar 1 1 (pass by 4 4 pillars in total) and robot of type Q will stop at pillar 5 5 (pass by 0 0 pillars in total), which breaks the condition. If the heights are 3\\,2\\,4\\,2\\,3 3\\,2\\,4\\,2\\,3 respectively. We can show that no matter which number s s is, the condition is always satisfied.","title":"Explanation"},{"location":"NOI/2019/Day1-B/#constraints","text":"For all of the tests, 1 \\leq n \\leq 300 1 \\leq n \\leq 300 , 1 \\leq A_i \\leq B_i \\leq 10^9 1 \\leq A_i \\leq B_i \\leq 10^9 . For partial scores, you can look up at the origin statement ( NOI/2019/Day1.pdf ).","title":"Constraints"},{"location":"NOI/2019/Day1-C/","text":"Time limit per test : \\texttt{1 s} \\texttt{1 s} Memory limit per test : \\texttt{512 MB} \\texttt{512 MB} You can submit this problem at: LibreOJ Input : sequence.in Output : sequence.out Luogu UOJ Description \u00b6 You are given two sequences \\{a_i\\} \\{a_i\\} and \\{b_i\\} \\{b_i\\} of length n n , and the element of them are indexed from 1 1 to n n . You need to choose K K numbers in each sequence, and ensure that at least L L positions are chosen in both sequences. Your task is to maximize the sum of the 2K 2K numbers. Formally speaking, you need to assign 2 2 sequences \\{c_i\\} \\{c_i\\} and \\{d_i\\} \\{d_i\\} of length K K such that 1 \\leq c_1 < c_2 < \\cdots < c_K \\leq n 1 \\leq c_1 < c_2 < \\cdots < c_K \\leq n 1 \\leq d_1 < d_2 < \\cdots < d_K \\leq n 1 \\leq d_1 < d_2 < \\cdots < d_K \\leq n \\left\\lvert\\{c_1, c_2, \\cdots, c_K\\} \\cap \\{d_1, d_2, \\cdots, d_K\\}\\right\\rvert \\geq L \\left\\lvert\\{c_1, c_2, \\cdots, c_K\\} \\cap \\{d_1, d_2, \\cdots, d_K\\}\\right\\rvert \\geq L Your goal is to maximize $$ \\sum_{i=1}^{K}{a_{c_i}} + \\sum_{i=1}^{K}{b_{d_i}} $$ Input \u00b6 The first line contains a single integer T T \u2014 the number of test cases. Each test case contains 3 3 lines. The first line contains 3 3 integers n, K, L n, K, L . The second line contains n n integers a_1, a_2, \\cdots, a_n a_1, a_2, \\cdots, a_n . The third line contains n n integers b_1, b_2, \\cdots, b_n b_1, b_2, \\cdots, b_n . Output \u00b6 For each test case, print a single integer \u2014 the maximal sum. Samples \u00b6 Sample 1 \u00b6 Input \u00b6 5 1 1 1 7 7 3 2 1 4 1 2 1 4 2 5 2 1 4 5 5 8 4 2 1 7 2 7 6 4 1 1 5 8 3 2 4 2 6 9 3 1 7 7 5 4 1 6 6 6 5 9 1 9 5 3 9 1 4 2 Output \u00b6 14 12 27 45 62 Explanation \u00b6 For the first case, \\{c_i\\} = \\{d_i\\} = \\{1\\} \\{c_i\\} = \\{d_i\\} = \\{1\\} . For the second case, \\{c_i\\} = \\{1, 3\\} \\{c_i\\} = \\{1, 3\\} , \\{d_i\\} = \\{2, 3\\} \\{d_i\\} = \\{2, 3\\} . For the third case, \\{c_i\\} = \\{3, 4\\} \\{c_i\\} = \\{3, 4\\} , \\{d_i\\} = \\{3, 5\\} \\{d_i\\} = \\{3, 5\\} . For the fourth case, \\{c_i\\} = \\{d_i\\} = \\{2, 3, 4, 6\\} \\{c_i\\} = \\{d_i\\} = \\{2, 3, 4, 6\\} . For the fifth case, \\{c_i\\} = \\{2, 3, 4, 5, 6\\} \\{c_i\\} = \\{2, 3, 4, 5, 6\\} , \\{d_i\\} = \\{1, 2, 3, 4, 6\\} \\{d_i\\} = \\{1, 2, 3, 4, 6\\} . Constraints \u00b6 For all of the tests, T \\leq 10 T \\leq 10 , 1 \\leq \\sum{n} \\leq 10^6 1 \\leq \\sum{n} \\leq 10^6 , 1 \\leq L \\leq K \\leq n \\leq 2 \\times 10^5 1 \\leq L \\leq K \\leq n \\leq 2 \\times 10^5 , 1 \\leq a_i, b_i \\leq 10^9 1 \\leq a_i, b_i \\leq 10^9 . For partial scores, you can look up at the origin statement ( NOI/2019/Day1.pdf ).","title":"Day 1, Task C"},{"location":"NOI/2019/Day1-C/#description","text":"You are given two sequences \\{a_i\\} \\{a_i\\} and \\{b_i\\} \\{b_i\\} of length n n , and the element of them are indexed from 1 1 to n n . You need to choose K K numbers in each sequence, and ensure that at least L L positions are chosen in both sequences. Your task is to maximize the sum of the 2K 2K numbers. Formally speaking, you need to assign 2 2 sequences \\{c_i\\} \\{c_i\\} and \\{d_i\\} \\{d_i\\} of length K K such that 1 \\leq c_1 < c_2 < \\cdots < c_K \\leq n 1 \\leq c_1 < c_2 < \\cdots < c_K \\leq n 1 \\leq d_1 < d_2 < \\cdots < d_K \\leq n 1 \\leq d_1 < d_2 < \\cdots < d_K \\leq n \\left\\lvert\\{c_1, c_2, \\cdots, c_K\\} \\cap \\{d_1, d_2, \\cdots, d_K\\}\\right\\rvert \\geq L \\left\\lvert\\{c_1, c_2, \\cdots, c_K\\} \\cap \\{d_1, d_2, \\cdots, d_K\\}\\right\\rvert \\geq L Your goal is to maximize $$ \\sum_{i=1}^{K}{a_{c_i}} + \\sum_{i=1}^{K}{b_{d_i}} $$","title":"Description"},{"location":"NOI/2019/Day1-C/#input","text":"The first line contains a single integer T T \u2014 the number of test cases. Each test case contains 3 3 lines. The first line contains 3 3 integers n, K, L n, K, L . The second line contains n n integers a_1, a_2, \\cdots, a_n a_1, a_2, \\cdots, a_n . The third line contains n n integers b_1, b_2, \\cdots, b_n b_1, b_2, \\cdots, b_n .","title":"Input"},{"location":"NOI/2019/Day1-C/#output","text":"For each test case, print a single integer \u2014 the maximal sum.","title":"Output"},{"location":"NOI/2019/Day1-C/#samples","text":"","title":"Samples"},{"location":"NOI/2019/Day1-C/#sample-1","text":"","title":"Sample 1"},{"location":"NOI/2019/Day1-C/#input_1","text":"5 1 1 1 7 7 3 2 1 4 1 2 1 4 2 5 2 1 4 5 5 8 4 2 1 7 2 7 6 4 1 1 5 8 3 2 4 2 6 9 3 1 7 7 5 4 1 6 6 6 5 9 1 9 5 3 9 1 4 2","title":"Input"},{"location":"NOI/2019/Day1-C/#output_1","text":"14 12 27 45 62","title":"Output"},{"location":"NOI/2019/Day1-C/#explanation","text":"For the first case, \\{c_i\\} = \\{d_i\\} = \\{1\\} \\{c_i\\} = \\{d_i\\} = \\{1\\} . For the second case, \\{c_i\\} = \\{1, 3\\} \\{c_i\\} = \\{1, 3\\} , \\{d_i\\} = \\{2, 3\\} \\{d_i\\} = \\{2, 3\\} . For the third case, \\{c_i\\} = \\{3, 4\\} \\{c_i\\} = \\{3, 4\\} , \\{d_i\\} = \\{3, 5\\} \\{d_i\\} = \\{3, 5\\} . For the fourth case, \\{c_i\\} = \\{d_i\\} = \\{2, 3, 4, 6\\} \\{c_i\\} = \\{d_i\\} = \\{2, 3, 4, 6\\} . For the fifth case, \\{c_i\\} = \\{2, 3, 4, 5, 6\\} \\{c_i\\} = \\{2, 3, 4, 5, 6\\} , \\{d_i\\} = \\{1, 2, 3, 4, 6\\} \\{d_i\\} = \\{1, 2, 3, 4, 6\\} .","title":"Explanation"},{"location":"NOI/2019/Day1-C/#constraints","text":"For all of the tests, T \\leq 10 T \\leq 10 , 1 \\leq \\sum{n} \\leq 10^6 1 \\leq \\sum{n} \\leq 10^6 , 1 \\leq L \\leq K \\leq n \\leq 2 \\times 10^5 1 \\leq L \\leq K \\leq n \\leq 2 \\times 10^5 , 1 \\leq a_i, b_i \\leq 10^9 1 \\leq a_i, b_i \\leq 10^9 . For partial scores, you can look up at the origin statement ( NOI/2019/Day1.pdf ).","title":"Constraints"},{"location":"NOI/2019/Day2-A/","text":"Time limit per test : \\texttt{2 s} \\texttt{2 s} Memory limit per test : \\texttt{128 MB} \\texttt{128 MB} You can submit this problem at: LibreOJ Input : jump.in Output : jump.out Luogu UOJ Description \u00b6 There are n n cities in the Kingdom of Flea, numbered from 1 1 to n n , and city 1 1 is the capital. All of the cities are located in a grid graph of size w \\times h w \\times h . Each city has an integer coordinate (x, y)\\,(1 \\leq x \\leq w, 1 \\leq y \\leq h) (x, y)\\,(1 \\leq x \\leq w, 1 \\leq y \\leq h) , and the coordinates of the cities are different from each other. There are m m bouncing devices in the Kingdom of Flea, numbered from 1 1 to m m . The i i -th device is located in city p_i p_i and with this device, a flea in city p_i p_i can jump to any city that satisfies L_i \\leq x \\leq R_i L_i \\leq x \\leq R_i , D_i \\leq y \\leq U_i D_i \\leq y \\leq U_i in t_i t_i time units. Since that the cities are quite far away from each other, so fleas always travel by the bouncing devices. Specifically, during a trip a flea will pass through several cities in turn, whose indices are a_0, a_1, \\cdots, a_k a_0, a_1, \\cdots, a_k , respectively; in this trip, the indices of bouncing devices used in turn are b_1, b_2, \\cdots, b_k b_1, b_2, \\cdots, b_k . Each cities can appear any number of times in the sequence \\{a_j\\} \\{a_j\\} , and each bouncing devices can appear any number of times in the sequence \\{b_j\\} \\{b_j\\} and for each j\\, (1 \\leq j \\leq k) j\\, (1 \\leq j \\leq k) , bouncing devices b_j b_j is located in the city a_{j\u22121} a_{j\u22121} and the flea can jump to city a_j a_j with the help of the bouncer. We call this a trip from city a_0 a_0 to city a_k a_k , which costs \\sum_{i=1}^{k}{t_{b_i}} \\sum_{i=1}^{k}{t_{b_i}} time units. Now the Flea King wants to know that for every city except the capital of the kingdom (city 1 1 ), how much time it will at least take to get to the city from the capital. Input \u00b6 The first line contains 4 4 integers n, m, w, h n, m, w, h . Each of the next n n lines contains 2 2 integers x_i, y_i x_i, y_i . Each of the next m m lines contains 6 6 integers p_i, t_i, L_i, R_i, D_i, U_i p_i, t_i, L_i, R_i, D_i, U_i , describing the information of the i i -th bouncing device. It's guaranteed that every city is reachable from the capital. Output \u00b6 You should print n - 1 n - 1 lines, the i i -th line contains the minimum time it needs to get to city i + 1 i + 1 from the capital. Samples \u00b6 Sample 1 \u00b6 Input \u00b6 5 3 5 5 1 1 3 1 4 1 2 2 3 3 1 123 1 5 1 5 1 50 1 5 1 1 3 10 2 2 2 2 Output \u00b6 50 50 60 123 Constraints \u00b6 1 \\leq n \\leq 70000 1 \\leq n \\leq 70000 1 \\leq m \\leq 150000 1 \\leq m \\leq 150000 1 \\leq w, h \\leq n 1 \\leq w, h \\leq n 1 \\leq t_i \\leq 10000 1 \\leq t_i \\leq 10000 For partial scores, you can look up at the origin statement ( NOI/2019/Day2.pdf ). Please note that the memory limit of this problem is 128 MB.","title":"Day 2, Task A"},{"location":"NOI/2019/Day2-A/#description","text":"There are n n cities in the Kingdom of Flea, numbered from 1 1 to n n , and city 1 1 is the capital. All of the cities are located in a grid graph of size w \\times h w \\times h . Each city has an integer coordinate (x, y)\\,(1 \\leq x \\leq w, 1 \\leq y \\leq h) (x, y)\\,(1 \\leq x \\leq w, 1 \\leq y \\leq h) , and the coordinates of the cities are different from each other. There are m m bouncing devices in the Kingdom of Flea, numbered from 1 1 to m m . The i i -th device is located in city p_i p_i and with this device, a flea in city p_i p_i can jump to any city that satisfies L_i \\leq x \\leq R_i L_i \\leq x \\leq R_i , D_i \\leq y \\leq U_i D_i \\leq y \\leq U_i in t_i t_i time units. Since that the cities are quite far away from each other, so fleas always travel by the bouncing devices. Specifically, during a trip a flea will pass through several cities in turn, whose indices are a_0, a_1, \\cdots, a_k a_0, a_1, \\cdots, a_k , respectively; in this trip, the indices of bouncing devices used in turn are b_1, b_2, \\cdots, b_k b_1, b_2, \\cdots, b_k . Each cities can appear any number of times in the sequence \\{a_j\\} \\{a_j\\} , and each bouncing devices can appear any number of times in the sequence \\{b_j\\} \\{b_j\\} and for each j\\, (1 \\leq j \\leq k) j\\, (1 \\leq j \\leq k) , bouncing devices b_j b_j is located in the city a_{j\u22121} a_{j\u22121} and the flea can jump to city a_j a_j with the help of the bouncer. We call this a trip from city a_0 a_0 to city a_k a_k , which costs \\sum_{i=1}^{k}{t_{b_i}} \\sum_{i=1}^{k}{t_{b_i}} time units. Now the Flea King wants to know that for every city except the capital of the kingdom (city 1 1 ), how much time it will at least take to get to the city from the capital.","title":"Description"},{"location":"NOI/2019/Day2-A/#input","text":"The first line contains 4 4 integers n, m, w, h n, m, w, h . Each of the next n n lines contains 2 2 integers x_i, y_i x_i, y_i . Each of the next m m lines contains 6 6 integers p_i, t_i, L_i, R_i, D_i, U_i p_i, t_i, L_i, R_i, D_i, U_i , describing the information of the i i -th bouncing device. It's guaranteed that every city is reachable from the capital.","title":"Input"},{"location":"NOI/2019/Day2-A/#output","text":"You should print n - 1 n - 1 lines, the i i -th line contains the minimum time it needs to get to city i + 1 i + 1 from the capital.","title":"Output"},{"location":"NOI/2019/Day2-A/#samples","text":"","title":"Samples"},{"location":"NOI/2019/Day2-A/#sample-1","text":"","title":"Sample 1"},{"location":"NOI/2019/Day2-A/#input_1","text":"5 3 5 5 1 1 3 1 4 1 2 2 3 3 1 123 1 5 1 5 1 50 1 5 1 1 3 10 2 2 2 2","title":"Input"},{"location":"NOI/2019/Day2-A/#output_1","text":"50 50 60 123","title":"Output"},{"location":"NOI/2019/Day2-A/#constraints","text":"1 \\leq n \\leq 70000 1 \\leq n \\leq 70000 1 \\leq m \\leq 150000 1 \\leq m \\leq 150000 1 \\leq w, h \\leq n 1 \\leq w, h \\leq n 1 \\leq t_i \\leq 10000 1 \\leq t_i \\leq 10000 For partial scores, you can look up at the origin statement ( NOI/2019/Day2.pdf ). Please note that the memory limit of this problem is 128 MB.","title":"Constraints"},{"location":"NOI/2019/Day2-B/","text":"Time limit per test : \\texttt{4 s} \\texttt{4 s} Memory limit per test : \\texttt{512 MB} \\texttt{512 MB} You can submit this problem at: LibreOJ Input : landlords.in Output : landlords.out Luogu UOJ Description \u00b6 Alice and Bob are playing card games, but Alice found that she can never win Bob, so she plans to cheat in the shuffling session. There are n n cards in total, numbered from 1 1 to n n from top to bottom. The card with index i i has a score of f(i) f(i) . In this problem, f(i) = i f(i) = i or f(i) = i^2 f(i) = i^2 always holds. The whole shuffling session can be devided into m m rounds. During the i i -th round: Alice will take A_i A_i cards from the top, then all the cards are divided into 2 piles: the first contains A_i A_i cards from the top, the second contains the remaining n - A_i n - A_i cards. In particular, when A_i = 0 A_i = 0 or A_i = n A_i = n , one of the piles will be empty. Then Alice will merge the two piles in the following way. When there are X X cards left in the first pile and Y Y in the second, she will take the card at the bottom of the first pile with the probability of \\frac{X}{X + Y} \\frac{X}{X + Y} , and put it on the top of the new pile; otherwise she will take the card at the bottom of the second pile and put it on the top of the new pile. Since the shuffling session is random, Alice can't know which card it is at a certain position. But Alice wants to know the expected score of the card at a certain position after m m rounds of shuffling. Input \u00b6 The first line contains 3 3 integers n, m, \\text{type} n, m, \\text{type} . When \\text{type} = 1 \\text{type} = 1 , f(i) = i f(i) = i , otherwise f(i) = i^2 f(i) = i^2 . The second line contains m m integers A_1, A_2, \\cdots, A_m A_1, A_2, \\cdots, A_m . The third line contains a single integer Q Q \u2014 the number of queries. Each of the next Q Q lines contains a single integer c_i c_i . Output \u00b6 You should print Q Q lines, the i i -th line contains the expected score of the c_i c_i -th card from top to bottom. You should print the answer module 998244353 998244353 , that is, if the answer is \\frac{a}{b} \\frac{a}{b} , where (a, b) = 1 (a, b) = 1 , you should print an integer x x such that bx \\equiv a \\pmod{998244353} bx \\equiv a \\pmod{998244353} and 0 \\leq x < 998244353 0 \\leq x < 998244353 . One can prove that such x x is unique. Samples \u00b6 Sample 1 \u00b6 Input \u00b6 4 1 1 3 1 1 Output \u00b6 249561090 Explanation \u00b6 After shuffling, the cards will become: \\{1, 2, 3, 4\\} \\{1, 2, 3, 4\\} from top to bottom with the probability of \\frac{1}{4} \\frac{1}{4} \\{1, 2, 4, 3\\} \\{1, 2, 4, 3\\} from top to bottom with the probability of \\frac{1}{4} \\frac{1}{4} \\{1, 4, 2, 3\\} \\{1, 4, 2, 3\\} from top to bottom with the probability of \\frac{1}{4} \\frac{1}{4} \\{4, 1, 2, 3\\} \\{4, 1, 2, 3\\} from top to bottom with the probability of \\frac{1}{4} \\frac{1}{4} So the expected score of the first place is \\frac{1}{4}(1 + 1 + 1 + 4) = \\frac{7}{4} \\frac{1}{4}(1 + 1 + 1 + 4) = \\frac{7}{4} . If you still have no idea how the it shuffles, some pictures in the Chinese statement ( 2019-NOI-Day2.pdf ) will show you how to get \\{1, 4, 2, 3\\} \\{1, 4, 2, 3\\} . Constraints \u00b6 3 \\leq n \\leq 10^7 3 \\leq n \\leq 10^7 1 \\leq m, Q \\leq 5 \\times 10^5 1 \\leq m, Q \\leq 5 \\times 10^5 0 \\leq A_i \\leq n 0 \\leq A_i \\leq n \\text{type} \\in \\{1, 2\\} \\text{type} \\in \\{1, 2\\} For partial scores, you can look up at the origin statement ( NOI/2019/Day2.pdf ).","title":"Day 2, Task B"},{"location":"NOI/2019/Day2-B/#description","text":"Alice and Bob are playing card games, but Alice found that she can never win Bob, so she plans to cheat in the shuffling session. There are n n cards in total, numbered from 1 1 to n n from top to bottom. The card with index i i has a score of f(i) f(i) . In this problem, f(i) = i f(i) = i or f(i) = i^2 f(i) = i^2 always holds. The whole shuffling session can be devided into m m rounds. During the i i -th round: Alice will take A_i A_i cards from the top, then all the cards are divided into 2 piles: the first contains A_i A_i cards from the top, the second contains the remaining n - A_i n - A_i cards. In particular, when A_i = 0 A_i = 0 or A_i = n A_i = n , one of the piles will be empty. Then Alice will merge the two piles in the following way. When there are X X cards left in the first pile and Y Y in the second, she will take the card at the bottom of the first pile with the probability of \\frac{X}{X + Y} \\frac{X}{X + Y} , and put it on the top of the new pile; otherwise she will take the card at the bottom of the second pile and put it on the top of the new pile. Since the shuffling session is random, Alice can't know which card it is at a certain position. But Alice wants to know the expected score of the card at a certain position after m m rounds of shuffling.","title":"Description"},{"location":"NOI/2019/Day2-B/#input","text":"The first line contains 3 3 integers n, m, \\text{type} n, m, \\text{type} . When \\text{type} = 1 \\text{type} = 1 , f(i) = i f(i) = i , otherwise f(i) = i^2 f(i) = i^2 . The second line contains m m integers A_1, A_2, \\cdots, A_m A_1, A_2, \\cdots, A_m . The third line contains a single integer Q Q \u2014 the number of queries. Each of the next Q Q lines contains a single integer c_i c_i .","title":"Input"},{"location":"NOI/2019/Day2-B/#output","text":"You should print Q Q lines, the i i -th line contains the expected score of the c_i c_i -th card from top to bottom. You should print the answer module 998244353 998244353 , that is, if the answer is \\frac{a}{b} \\frac{a}{b} , where (a, b) = 1 (a, b) = 1 , you should print an integer x x such that bx \\equiv a \\pmod{998244353} bx \\equiv a \\pmod{998244353} and 0 \\leq x < 998244353 0 \\leq x < 998244353 . One can prove that such x x is unique.","title":"Output"},{"location":"NOI/2019/Day2-B/#samples","text":"","title":"Samples"},{"location":"NOI/2019/Day2-B/#sample-1","text":"","title":"Sample 1"},{"location":"NOI/2019/Day2-B/#input_1","text":"4 1 1 3 1 1","title":"Input"},{"location":"NOI/2019/Day2-B/#output_1","text":"249561090","title":"Output"},{"location":"NOI/2019/Day2-B/#explanation","text":"After shuffling, the cards will become: \\{1, 2, 3, 4\\} \\{1, 2, 3, 4\\} from top to bottom with the probability of \\frac{1}{4} \\frac{1}{4} \\{1, 2, 4, 3\\} \\{1, 2, 4, 3\\} from top to bottom with the probability of \\frac{1}{4} \\frac{1}{4} \\{1, 4, 2, 3\\} \\{1, 4, 2, 3\\} from top to bottom with the probability of \\frac{1}{4} \\frac{1}{4} \\{4, 1, 2, 3\\} \\{4, 1, 2, 3\\} from top to bottom with the probability of \\frac{1}{4} \\frac{1}{4} So the expected score of the first place is \\frac{1}{4}(1 + 1 + 1 + 4) = \\frac{7}{4} \\frac{1}{4}(1 + 1 + 1 + 4) = \\frac{7}{4} . If you still have no idea how the it shuffles, some pictures in the Chinese statement ( 2019-NOI-Day2.pdf ) will show you how to get \\{1, 4, 2, 3\\} \\{1, 4, 2, 3\\} .","title":"Explanation"},{"location":"NOI/2019/Day2-B/#constraints","text":"3 \\leq n \\leq 10^7 3 \\leq n \\leq 10^7 1 \\leq m, Q \\leq 5 \\times 10^5 1 \\leq m, Q \\leq 5 \\times 10^5 0 \\leq A_i \\leq n 0 \\leq A_i \\leq n \\text{type} \\in \\{1, 2\\} \\text{type} \\in \\{1, 2\\} For partial scores, you can look up at the origin statement ( NOI/2019/Day2.pdf ).","title":"Constraints"},{"location":"NOI/2019/Day2-C/","text":"Time limit per test : \\texttt{2 s} \\texttt{2 s} Memory limit per test : \\texttt{512 MB} \\texttt{512 MB} You can submit this problem at: LibreOJ Only C++ is available. UOJ Both C/C++ and Pascal are available. This is an interactive problem. Description \u00b6 The underground palace consists of N N caves and M M roads between them, which can be represented as an undirected simple graph of N N vertices and M M edges. The caves are numbered from 0 0 to n - 1 n - 1 , and you have no idea where the roads are. There is a light in each cave, all of them are either off or on. Initially, all the lights are off, and the status of the lights can be changed only by the mysterious machine in your hand. Specifically, it can perform the following 4 4 operations: For a certain x x , it will change the status of the lights in cave x x and the caves that directly connected to cave x x . That is, turn on the light if it's off, and turn off the light if it's on. For a certain x x , it will show you the current status of the lights in cave x x . For certain x, y x, y , it will record an edge between cave x x and cave y y . For a certain x x , it will tell whether all the roads connected to cave x x are recorded. The machine can only deal with one operation at the same time, and the number of uses for each operation is limited, L_m, L_q, M, L_c L_m, L_q, M, L_c respectively. Your task is to write a program to find all the M M edges correctly. Implementation details \u00b6 You should implement the following function: void explore ( int N , int M ); \\texttt{N} \\texttt{N} : the number of caves. \\texttt{M} \\texttt{M} : the number of roads. This function is called exactly once for each test case. Your program can call the following function: void modify ( int x ); \\texttt{x} \\texttt{x} : The index of the cave you want to operate on. You should guarantee that 0 \\leq x < N 0 \\leq x < N . You cannot call this function more than L_m L_m times for each test case. This function will perform the first operation on cave x x and return nothing. int query ( int x ); \\texttt{x} \\texttt{x} : The index of the cave you want to operate on. You should guarantee that 0 \\leq x < N 0 \\leq x < N . You cannot call this function more than L_q L_q times for each test case. This function will perform the second operation on cave x x . This function will return 1 if the light in cave x x in on, and 0 otherwise. void report ( int x , int y ); \\texttt{x}, \\texttt{y} \\texttt{x}, \\texttt{y} : The indeies of the caves you want to operate on. You should guarantee that 0 \\leq x, y < N 0 \\leq x, y < N and x \\neq y x \\neq y . You cannot call this function more than M M times for each test case. This function will record an edge between cave x x and cave y y , and return nothing. int check ( int x ); \\texttt{x} \\texttt{x} : The index of the cave you want to operate on. You should guarantee that 0 \\leq x < N 0 \\leq x < N . You cannot call this function more than L_c L_c times for each test case. This function will perform the fourth operation on cave x x . This function will return 1 if all the roads connected to cave x x are recorded, and 0 otherwise. In this problem, the grader is NOT adaptive. This means that the graph is fixed at the beginning of the running of the grader and it does not depend on the operations performed by your solution. It is guaranteed that grader will use no more than \\texttt{1 s} \\texttt{1 s} of time and no more than \\texttt{128 MB} \\texttt{128 MB} of memory. Sample grader \u00b6 The sample grader reads the input in the following format: The first line contains 3 3 integers L_m, L_q, L_c L_m, L_q, L_c . The second line contains 2 2 integers N, M N, M . Each of the next M M lines contains 2 2 integers x, y x, y , refers to an road between cave x x and cave y y . If your program is judged as Accepted , the sample grader prints Correct and the number of times you call each function. Otherwise it will print what's wrong with your solution. Sample \u00b6 You can find an example of communication in the Chinese statement ( NOI/2019/Day2.pdf ). Constraints \u00b6 3 \\leq N \\leq 200000 3 \\leq N \\leq 200000 2 \\leq M \\leq 300000 2 \\leq M \\leq 300000 The constraints of each test can be found in the origin statement ( NOI/2019/Day2.pdf ). Note: the lowest digit of N N may help you get partial scores easilier.","title":"Day 2, Task C"},{"location":"NOI/2019/Day2-C/#description","text":"The underground palace consists of N N caves and M M roads between them, which can be represented as an undirected simple graph of N N vertices and M M edges. The caves are numbered from 0 0 to n - 1 n - 1 , and you have no idea where the roads are. There is a light in each cave, all of them are either off or on. Initially, all the lights are off, and the status of the lights can be changed only by the mysterious machine in your hand. Specifically, it can perform the following 4 4 operations: For a certain x x , it will change the status of the lights in cave x x and the caves that directly connected to cave x x . That is, turn on the light if it's off, and turn off the light if it's on. For a certain x x , it will show you the current status of the lights in cave x x . For certain x, y x, y , it will record an edge between cave x x and cave y y . For a certain x x , it will tell whether all the roads connected to cave x x are recorded. The machine can only deal with one operation at the same time, and the number of uses for each operation is limited, L_m, L_q, M, L_c L_m, L_q, M, L_c respectively. Your task is to write a program to find all the M M edges correctly.","title":"Description"},{"location":"NOI/2019/Day2-C/#implementation-details","text":"You should implement the following function: void explore ( int N , int M ); \\texttt{N} \\texttt{N} : the number of caves. \\texttt{M} \\texttt{M} : the number of roads. This function is called exactly once for each test case. Your program can call the following function: void modify ( int x ); \\texttt{x} \\texttt{x} : The index of the cave you want to operate on. You should guarantee that 0 \\leq x < N 0 \\leq x < N . You cannot call this function more than L_m L_m times for each test case. This function will perform the first operation on cave x x and return nothing. int query ( int x ); \\texttt{x} \\texttt{x} : The index of the cave you want to operate on. You should guarantee that 0 \\leq x < N 0 \\leq x < N . You cannot call this function more than L_q L_q times for each test case. This function will perform the second operation on cave x x . This function will return 1 if the light in cave x x in on, and 0 otherwise. void report ( int x , int y ); \\texttt{x}, \\texttt{y} \\texttt{x}, \\texttt{y} : The indeies of the caves you want to operate on. You should guarantee that 0 \\leq x, y < N 0 \\leq x, y < N and x \\neq y x \\neq y . You cannot call this function more than M M times for each test case. This function will record an edge between cave x x and cave y y , and return nothing. int check ( int x ); \\texttt{x} \\texttt{x} : The index of the cave you want to operate on. You should guarantee that 0 \\leq x < N 0 \\leq x < N . You cannot call this function more than L_c L_c times for each test case. This function will perform the fourth operation on cave x x . This function will return 1 if all the roads connected to cave x x are recorded, and 0 otherwise. In this problem, the grader is NOT adaptive. This means that the graph is fixed at the beginning of the running of the grader and it does not depend on the operations performed by your solution. It is guaranteed that grader will use no more than \\texttt{1 s} \\texttt{1 s} of time and no more than \\texttt{128 MB} \\texttt{128 MB} of memory.","title":"Implementation details"},{"location":"NOI/2019/Day2-C/#sample-grader","text":"The sample grader reads the input in the following format: The first line contains 3 3 integers L_m, L_q, L_c L_m, L_q, L_c . The second line contains 2 2 integers N, M N, M . Each of the next M M lines contains 2 2 integers x, y x, y , refers to an road between cave x x and cave y y . If your program is judged as Accepted , the sample grader prints Correct and the number of times you call each function. Otherwise it will print what's wrong with your solution.","title":"Sample grader"},{"location":"NOI/2019/Day2-C/#sample","text":"You can find an example of communication in the Chinese statement ( NOI/2019/Day2.pdf ).","title":"Sample"},{"location":"NOI/2019/Day2-C/#constraints","text":"3 \\leq N \\leq 200000 3 \\leq N \\leq 200000 2 \\leq M \\leq 300000 2 \\leq M \\leq 300000 The constraints of each test can be found in the origin statement ( NOI/2019/Day2.pdf ). Note: the lowest digit of N N may help you get partial scores easilier.","title":"Constraints"}]}