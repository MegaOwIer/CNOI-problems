{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CNOI Problem Archive \u00b6 This is an online archive of English statements of Chinese OI problems. You can find most of the files mentioned in this site (statements in Chinese, extra samples, etc.) in the repository . If you find some of my translation vague, you can look up the Chinese statement and use Google translate. Sorry if my poor English does make you confused. By the way, anyone is welcomed to contribute translations or help to correct the mistakes.","title":"Home"},{"location":"#cnoi-problem-archive","text":"This is an online archive of English statements of Chinese OI problems. You can find most of the files mentioned in this site (statements in Chinese, extra samples, etc.) in the repository . If you find some of my translation vague, you can look up the Chinese statement and use Google translate. Sorry if my poor English does make you confused. By the way, anyone is welcomed to contribute translations or help to correct the mistakes.","title":"CNOI Problem Archive"},{"location":"about/","text":"A brief introduction to the contests mentioned in this site will be added here in the future.","title":"About the Contests"},{"location":"NOI/2018/Day1-A/","text":"Coming Soon...","title":"Task A, Day 1"},{"location":"NOI/2019/Day1-A/","text":"Time limit per test : \\texttt{1 s} \\texttt{1 s} Memory limit per test : \\texttt{512 MB} \\texttt{512 MB} You can submit this problem at: LibreOJ Input : route.in Output : route.out Luogu (original test cases) Or you can try to submit here , whose test cases are stronger. UOJ Description \u00b6 There are n n railway stations in the Kingdom of Cat, numbered from 1 1 to n n . Little cat is going home (at station n n ) from station 1 1 . There are m m trains in the kingdom, numbered from 1 1 to m m . For the i i -th train, it will depart station x_i x_i at time p_i p_i , and arrive at station station y_i y_i directly at time q_i q_i . At time 0 0 , little cat is at station 1 1 . Little cat can go home by multiple transfers. One transfer is that for a pair of trains u u and v v , if y_u = x_v y_u = x_v and q_u \\leq p_v q_u \\leq p_v , then after taking train u u , little cat can wait at station y_u y_u for p_v - q_u p_v - q_u time units, and take train v v at time p_v p_v . Little cat wants to minimize its anxiety , which is calculated as followed: If little cat waits at some stations for t\\,(t \\geq 0) t\\,(t \\geq 0) time units, its anxiety will be increased by At^2 + Bt + C At^2 + Bt + C , where A, B, C A, B, C are given constants. Note that before little cat taking the first train at time t t , it has been waiting for t t time units at station 1 1 . If little cat arrives at station n n at time z z , its anxiety will be increased by z z . Formally, if little cat takes k k trains totally, whose numbers are s_1, s_2, \\cdots, s_k s_1, s_2, \\cdots, s_k , little cat can get home if and only if: x_{s_1} = 1, y_{s_k} = n x_{s_1} = 1, y_{s_k} = n y_{s_j} = x_{s_{j + 1}} y_{s_j} = x_{s_{j + 1}} and q_{s_j} \\leq p_{s_{j + 1}} q_{s_j} \\leq p_{s_{j + 1}} hold for 1 \\leq j < k 1 \\leq j < k and its anxiety will be $$ q_{s_k} + (A \\cdot p_{s_1}^2 + B \\cdot p_{s_1} + C) + \\sum_{j = 1}^{k - 1}\\left(A(p_{s_{j + 1}} - q_{s_j})^2 + B(p_{s_{j + 1}} - q_{s_j}) + C\\right) $$ Your task is to figure out the minimal anxiety. Input \u00b6 The first line contains 5 5 integers n, m, A, B, C n, m, A, B, C . Each of the next m m lines contains 4 4 integers p_i, q_i, x_i, y_i p_i, q_i, x_i, y_i . It is guaranteed that there is at least one way for little cat to go home. Output \u00b6 Print a single integer \u2014 the minimal anxiety. Samples \u00b6 Sample 1 \u00b6 Input \u00b6 3 4 1 5 10 1 2 3 4 1 2 5 7 1 2 6 8 2 3 9 10 Output \u00b6 94 Explanation \u00b6 There are 3 3 ways to go home. Take train 1, 4 1, 4 in turn, and the anxiety is 10 + 1 \\times 3^2 + 5 \\times 3 + 10 + 1 \\times (9-4)^2 + 5 \\times (9-4) + 10 = 104 10 + 1 \\times 3^2 + 5 \\times 3 + 10 + 1 \\times (9-4)^2 + 5 \\times (9-4) + 10 = 104 Take train 2, 4 2, 4 in turn, and the anxiety is 10 + 1 \\times 5^2 + 5 \\times 5 + 10 + 1 \\times (9-7)^2 + 5 \\times (9-7) + 10 = 94 10 + 1 \\times 5^2 + 5 \\times 5 + 10 + 1 \\times (9-7)^2 + 5 \\times (9-7) + 10 = 94 Take train 3, 4 3, 4 in turn, and the anxiety is 10 + 1 \\times 6^2 + 5 \\times 6 + 10 + 1 \\times (9-8)^2 + 5 \\times (9-8) + 10 = 102 10 + 1 \\times 6^2 + 5 \\times 6 + 10 + 1 \\times (9-8)^2 + 5 \\times (9-8) + 10 = 102 So the minimal anxiety is 94 94 . Sample 2 \u00b6 Input \u00b6 4 3 1 2 3 1 2 2 3 2 3 5 7 3 4 7 9 Output \u00b6 34 Constraints \u00b6 For all of the tests, 2 \\leq n \\leq 10^5 2 \\leq n \\leq 10^5 , 1 \\leq m \\leq 2 \\times 10^5 1 \\leq m \\leq 2 \\times 10^5 , 0 \\leq A \\leq 10 0 \\leq A \\leq 10 , 0 \\leq B, C \\leq 10^6 0 \\leq B, C \\leq 10^6 , 1 \\leq x_i, y_i \\leq n 1 \\leq x_i, y_i \\leq n , x_i \\neq y_i x_i \\neq y_i , 0 \\leq p_i < q_i \\leq 10^3 0 \\leq p_i < q_i \\leq 10^3 . For partial scores, you can look up at the origin statement ( NOI/2019/Day1.pdf ).","title":"Task A, Day 1"},{"location":"NOI/2019/Day1-A/#description","text":"There are n n railway stations in the Kingdom of Cat, numbered from 1 1 to n n . Little cat is going home (at station n n ) from station 1 1 . There are m m trains in the kingdom, numbered from 1 1 to m m . For the i i -th train, it will depart station x_i x_i at time p_i p_i , and arrive at station station y_i y_i directly at time q_i q_i . At time 0 0 , little cat is at station 1 1 . Little cat can go home by multiple transfers. One transfer is that for a pair of trains u u and v v , if y_u = x_v y_u = x_v and q_u \\leq p_v q_u \\leq p_v , then after taking train u u , little cat can wait at station y_u y_u for p_v - q_u p_v - q_u time units, and take train v v at time p_v p_v . Little cat wants to minimize its anxiety , which is calculated as followed: If little cat waits at some stations for t\\,(t \\geq 0) t\\,(t \\geq 0) time units, its anxiety will be increased by At^2 + Bt + C At^2 + Bt + C , where A, B, C A, B, C are given constants. Note that before little cat taking the first train at time t t , it has been waiting for t t time units at station 1 1 . If little cat arrives at station n n at time z z , its anxiety will be increased by z z . Formally, if little cat takes k k trains totally, whose numbers are s_1, s_2, \\cdots, s_k s_1, s_2, \\cdots, s_k , little cat can get home if and only if: x_{s_1} = 1, y_{s_k} = n x_{s_1} = 1, y_{s_k} = n y_{s_j} = x_{s_{j + 1}} y_{s_j} = x_{s_{j + 1}} and q_{s_j} \\leq p_{s_{j + 1}} q_{s_j} \\leq p_{s_{j + 1}} hold for 1 \\leq j < k 1 \\leq j < k and its anxiety will be $$ q_{s_k} + (A \\cdot p_{s_1}^2 + B \\cdot p_{s_1} + C) + \\sum_{j = 1}^{k - 1}\\left(A(p_{s_{j + 1}} - q_{s_j})^2 + B(p_{s_{j + 1}} - q_{s_j}) + C\\right) $$ Your task is to figure out the minimal anxiety.","title":"Description"},{"location":"NOI/2019/Day1-A/#input","text":"The first line contains 5 5 integers n, m, A, B, C n, m, A, B, C . Each of the next m m lines contains 4 4 integers p_i, q_i, x_i, y_i p_i, q_i, x_i, y_i . It is guaranteed that there is at least one way for little cat to go home.","title":"Input"},{"location":"NOI/2019/Day1-A/#output","text":"Print a single integer \u2014 the minimal anxiety.","title":"Output"},{"location":"NOI/2019/Day1-A/#samples","text":"","title":"Samples"},{"location":"NOI/2019/Day1-A/#sample-1","text":"","title":"Sample 1"},{"location":"NOI/2019/Day1-A/#input_1","text":"3 4 1 5 10 1 2 3 4 1 2 5 7 1 2 6 8 2 3 9 10","title":"Input"},{"location":"NOI/2019/Day1-A/#output_1","text":"94","title":"Output"},{"location":"NOI/2019/Day1-A/#explanation","text":"There are 3 3 ways to go home. Take train 1, 4 1, 4 in turn, and the anxiety is 10 + 1 \\times 3^2 + 5 \\times 3 + 10 + 1 \\times (9-4)^2 + 5 \\times (9-4) + 10 = 104 10 + 1 \\times 3^2 + 5 \\times 3 + 10 + 1 \\times (9-4)^2 + 5 \\times (9-4) + 10 = 104 Take train 2, 4 2, 4 in turn, and the anxiety is 10 + 1 \\times 5^2 + 5 \\times 5 + 10 + 1 \\times (9-7)^2 + 5 \\times (9-7) + 10 = 94 10 + 1 \\times 5^2 + 5 \\times 5 + 10 + 1 \\times (9-7)^2 + 5 \\times (9-7) + 10 = 94 Take train 3, 4 3, 4 in turn, and the anxiety is 10 + 1 \\times 6^2 + 5 \\times 6 + 10 + 1 \\times (9-8)^2 + 5 \\times (9-8) + 10 = 102 10 + 1 \\times 6^2 + 5 \\times 6 + 10 + 1 \\times (9-8)^2 + 5 \\times (9-8) + 10 = 102 So the minimal anxiety is 94 94 .","title":"Explanation"},{"location":"NOI/2019/Day1-A/#sample-2","text":"","title":"Sample 2"},{"location":"NOI/2019/Day1-A/#input_2","text":"4 3 1 2 3 1 2 2 3 2 3 5 7 3 4 7 9","title":"Input"},{"location":"NOI/2019/Day1-A/#output_2","text":"34","title":"Output"},{"location":"NOI/2019/Day1-A/#constraints","text":"For all of the tests, 2 \\leq n \\leq 10^5 2 \\leq n \\leq 10^5 , 1 \\leq m \\leq 2 \\times 10^5 1 \\leq m \\leq 2 \\times 10^5 , 0 \\leq A \\leq 10 0 \\leq A \\leq 10 , 0 \\leq B, C \\leq 10^6 0 \\leq B, C \\leq 10^6 , 1 \\leq x_i, y_i \\leq n 1 \\leq x_i, y_i \\leq n , x_i \\neq y_i x_i \\neq y_i , 0 \\leq p_i < q_i \\leq 10^3 0 \\leq p_i < q_i \\leq 10^3 . For partial scores, you can look up at the origin statement ( NOI/2019/Day1.pdf ).","title":"Constraints"},{"location":"NOI/2019/Day1-B/","text":"Time limit per test : \\texttt{3 s} \\texttt{3 s} Memory limit per test : \\texttt{512 MB} \\texttt{512 MB} You can submit this problem at: LibreOJ Input : robot.in Output : robot.out Luogu UOJ Description \u00b6 Recently, Bob invented 2 2 kinds of robots: type P and type Q. Now he wants to test the mobility of these two robots. There are n n pillars arranged in a row, numbered from 1 1 to n n . The i i -th pillar has a height of h_i h_i . The robots can only move between adjacent pillars, that is, if the robot is currently on the i i -th pillar. it can only move to the (i-1) (i-1) -th or (i+1) (i+1) -th pillar. In each test, Bob will choose a number s\\,(1 \\leq s \\leq n) s\\,(1 \\leq s \\leq n) , and put the robots on the s s -th pillar. Then the robots will move according to their own rules. Robots of type P will always move to the left , but it can't move to the pillars that are higher than pillar s s . Formally, it will stop at pllar l\\,(l \\leq s) l\\,(l \\leq s) if and only if: l = 1 l = 1 or h_{l-1} > h_s h_{l-1} > h_s h_j \\leq h_s h_j \\leq h_s holds for all l \\leq j \\leq s l \\leq j \\leq s Robots of type Q will always move to the right , but it can only move to the pillars that are shorter than pillar s s . Formally, it will stop at pllar r\\,(r \\leq s) r\\,(r \\leq s) if and only if: r = n r = n or h_{r+1} \\geq h_s h_{r+1} \\geq h_s h_j < h_s h_j < h_s holds for all s < j \\leq r s < j \\leq r Bob can set the height of all the pillars, the height of the i i -th pillar can be any integer in range [A_i, B_i] [A_i, B_i] . He wants to know how many possible ways are there to set the heights so that no matter which number s s is, the difference between the number of pillars that the robots pass by is not greater than 2 2 . Since the answer could be very large, you should print the answer module 10^9 + 7 10^9 + 7 instead. Input \u00b6 The first line contains a single integer n n . Each of the next n n lines contains twp integers A_i, B_i A_i, B_i . Output \u00b6 Print a single integer \u2014 the answer module 10^9 + 7 10^9 + 7 . Samples \u00b6 Sample 1 \u00b6 Input \u00b6 5 3 3 2 2 3 4 2 2 3 3 Note : In Chinese statement, the sample input isn't printed correctly. Output \u00b6 1 Explanation \u00b6 There are two possible ways to set the heights: If the heights are 3\\,2\\,3\\,2\\,3 3\\,2\\,3\\,2\\,3 respectively. When s = 5 s = 5 , we can see that Robot of type P will stop at pillar 1 1 (pass by 4 4 pillars in total) and robot of type Q will stop at pillar 5 5 (pass by 0 0 pillars in total), which breaks the condition. If the heights are 3\\,2\\,4\\,2\\,3 3\\,2\\,4\\,2\\,3 respectively. We can show that no matter which number s s is, the condition is always satisfied. Constraints \u00b6 For all of the tests, 1 \\leq n \\leq 300 1 \\leq n \\leq 300 , 1 \\leq A_i \\leq B_i \\leq 10^9 1 \\leq A_i \\leq B_i \\leq 10^9 . For partial scores, you can look up at the origin statement ( NOI/2019/Day1.pdf ).","title":"Task B, Day 1"},{"location":"NOI/2019/Day1-B/#description","text":"Recently, Bob invented 2 2 kinds of robots: type P and type Q. Now he wants to test the mobility of these two robots. There are n n pillars arranged in a row, numbered from 1 1 to n n . The i i -th pillar has a height of h_i h_i . The robots can only move between adjacent pillars, that is, if the robot is currently on the i i -th pillar. it can only move to the (i-1) (i-1) -th or (i+1) (i+1) -th pillar. In each test, Bob will choose a number s\\,(1 \\leq s \\leq n) s\\,(1 \\leq s \\leq n) , and put the robots on the s s -th pillar. Then the robots will move according to their own rules. Robots of type P will always move to the left , but it can't move to the pillars that are higher than pillar s s . Formally, it will stop at pllar l\\,(l \\leq s) l\\,(l \\leq s) if and only if: l = 1 l = 1 or h_{l-1} > h_s h_{l-1} > h_s h_j \\leq h_s h_j \\leq h_s holds for all l \\leq j \\leq s l \\leq j \\leq s Robots of type Q will always move to the right , but it can only move to the pillars that are shorter than pillar s s . Formally, it will stop at pllar r\\,(r \\leq s) r\\,(r \\leq s) if and only if: r = n r = n or h_{r+1} \\geq h_s h_{r+1} \\geq h_s h_j < h_s h_j < h_s holds for all s < j \\leq r s < j \\leq r Bob can set the height of all the pillars, the height of the i i -th pillar can be any integer in range [A_i, B_i] [A_i, B_i] . He wants to know how many possible ways are there to set the heights so that no matter which number s s is, the difference between the number of pillars that the robots pass by is not greater than 2 2 . Since the answer could be very large, you should print the answer module 10^9 + 7 10^9 + 7 instead.","title":"Description"},{"location":"NOI/2019/Day1-B/#input","text":"The first line contains a single integer n n . Each of the next n n lines contains twp integers A_i, B_i A_i, B_i .","title":"Input"},{"location":"NOI/2019/Day1-B/#output","text":"Print a single integer \u2014 the answer module 10^9 + 7 10^9 + 7 .","title":"Output"},{"location":"NOI/2019/Day1-B/#samples","text":"","title":"Samples"},{"location":"NOI/2019/Day1-B/#sample-1","text":"","title":"Sample 1"},{"location":"NOI/2019/Day1-B/#input_1","text":"5 3 3 2 2 3 4 2 2 3 3 Note : In Chinese statement, the sample input isn't printed correctly.","title":"Input"},{"location":"NOI/2019/Day1-B/#output_1","text":"1","title":"Output"},{"location":"NOI/2019/Day1-B/#explanation","text":"There are two possible ways to set the heights: If the heights are 3\\,2\\,3\\,2\\,3 3\\,2\\,3\\,2\\,3 respectively. When s = 5 s = 5 , we can see that Robot of type P will stop at pillar 1 1 (pass by 4 4 pillars in total) and robot of type Q will stop at pillar 5 5 (pass by 0 0 pillars in total), which breaks the condition. If the heights are 3\\,2\\,4\\,2\\,3 3\\,2\\,4\\,2\\,3 respectively. We can show that no matter which number s s is, the condition is always satisfied.","title":"Explanation"},{"location":"NOI/2019/Day1-B/#constraints","text":"For all of the tests, 1 \\leq n \\leq 300 1 \\leq n \\leq 300 , 1 \\leq A_i \\leq B_i \\leq 10^9 1 \\leq A_i \\leq B_i \\leq 10^9 . For partial scores, you can look up at the origin statement ( NOI/2019/Day1.pdf ).","title":"Constraints"},{"location":"NOI/2019/Day1-C/","text":"Time limit per test : \\texttt{1 s} \\texttt{1 s} Memory limit per test : \\texttt{512 MB} \\texttt{512 MB} You can submit this problem at: LibreOJ Input : sequence.in Output : sequence.out Luogu UOJ Description \u00b6 You are given two sequences \\{a_i\\} \\{a_i\\} and \\{b_i\\} \\{b_i\\} of length n n , and the element of them are indexed from 1 1 to n n . You need to choose K K numbers in each sequence, and ensure that at least L L positions are chosen in both sequences. Your task is to maximize the sum of the 2K 2K numbers. Formally speaking, you need to assign 2 2 sequences \\{c_i\\} \\{c_i\\} and \\{d_i\\} \\{d_i\\} of length K K such that 1 \\leq c_1 < c_2 < \\cdots < c_K \\leq n 1 \\leq c_1 < c_2 < \\cdots < c_K \\leq n 1 \\leq d_1 < d_2 < \\cdots < d_K \\leq n 1 \\leq d_1 < d_2 < \\cdots < d_K \\leq n \\left\\lvert\\{c_1, c_2, \\cdots, c_K\\} \\cap \\{d_1, d_2, \\cdots, d_K\\}\\right\\rvert \\geq L \\left\\lvert\\{c_1, c_2, \\cdots, c_K\\} \\cap \\{d_1, d_2, \\cdots, d_K\\}\\right\\rvert \\geq L Your goal is to maximize $$ \\sum_{i=1}^{K}{a_{c_i}} + \\sum_{i=1}^{K}{b_{d_i}} $$ Input \u00b6 The first line contains a single integer T T \u2014 the number of test cases. Each test case contains 3 3 lines. The first line contains 3 3 integers n, K, L n, K, L . The second line contains n n integers a_1, a_2, \\cdots, a_n a_1, a_2, \\cdots, a_n . The third line contains n n integers b_1, b_2, \\cdots, b_n b_1, b_2, \\cdots, b_n . Output \u00b6 For each test case, print a single integer \u2014 the maximal sum. Samples \u00b6 Sample 1 \u00b6 Input \u00b6 5 1 1 1 7 7 3 2 1 4 1 2 1 4 2 5 2 1 4 5 5 8 4 2 1 7 2 7 6 4 1 1 5 8 3 2 4 2 6 9 3 1 7 7 5 4 1 6 6 6 5 9 1 9 5 3 9 1 4 2 Output \u00b6 14 12 27 45 62 Explanation \u00b6 For the first case, \\{c_i\\} = \\{d_i\\} = \\{1\\} \\{c_i\\} = \\{d_i\\} = \\{1\\} . For the second case, \\{c_i\\} = \\{1, 3\\} \\{c_i\\} = \\{1, 3\\} , \\{d_i\\} = \\{2, 3\\} \\{d_i\\} = \\{2, 3\\} . For the third case, \\{c_i\\} = \\{3, 4\\} \\{c_i\\} = \\{3, 4\\} , \\{d_i\\} = \\{3, 5\\} \\{d_i\\} = \\{3, 5\\} . For the fourth case, \\{c_i\\} = \\{d_i\\} = \\{2, 3, 4, 6\\} \\{c_i\\} = \\{d_i\\} = \\{2, 3, 4, 6\\} . For the fifth case, \\{c_i\\} = \\{2, 3, 4, 5, 6\\} \\{c_i\\} = \\{2, 3, 4, 5, 6\\} , \\{d_i\\} = \\{1, 2, 3, 4, 6\\} \\{d_i\\} = \\{1, 2, 3, 4, 6\\} . Constraints \u00b6 For all of the tests, T \\leq 10 T \\leq 10 , 1 \\leq \\sum{n} \\leq 10^6 1 \\leq \\sum{n} \\leq 10^6 , 1 \\leq L \\leq K \\leq n \\leq 2 \\times 10^5 1 \\leq L \\leq K \\leq n \\leq 2 \\times 10^5 , 1 \\leq a_i, b_i \\leq 10^9 1 \\leq a_i, b_i \\leq 10^9 . For partial scores, you can look up at the origin statement ( NOI/2019/Day1.pdf ).","title":"Task C, Day 1"},{"location":"NOI/2019/Day1-C/#description","text":"You are given two sequences \\{a_i\\} \\{a_i\\} and \\{b_i\\} \\{b_i\\} of length n n , and the element of them are indexed from 1 1 to n n . You need to choose K K numbers in each sequence, and ensure that at least L L positions are chosen in both sequences. Your task is to maximize the sum of the 2K 2K numbers. Formally speaking, you need to assign 2 2 sequences \\{c_i\\} \\{c_i\\} and \\{d_i\\} \\{d_i\\} of length K K such that 1 \\leq c_1 < c_2 < \\cdots < c_K \\leq n 1 \\leq c_1 < c_2 < \\cdots < c_K \\leq n 1 \\leq d_1 < d_2 < \\cdots < d_K \\leq n 1 \\leq d_1 < d_2 < \\cdots < d_K \\leq n \\left\\lvert\\{c_1, c_2, \\cdots, c_K\\} \\cap \\{d_1, d_2, \\cdots, d_K\\}\\right\\rvert \\geq L \\left\\lvert\\{c_1, c_2, \\cdots, c_K\\} \\cap \\{d_1, d_2, \\cdots, d_K\\}\\right\\rvert \\geq L Your goal is to maximize $$ \\sum_{i=1}^{K}{a_{c_i}} + \\sum_{i=1}^{K}{b_{d_i}} $$","title":"Description"},{"location":"NOI/2019/Day1-C/#input","text":"The first line contains a single integer T T \u2014 the number of test cases. Each test case contains 3 3 lines. The first line contains 3 3 integers n, K, L n, K, L . The second line contains n n integers a_1, a_2, \\cdots, a_n a_1, a_2, \\cdots, a_n . The third line contains n n integers b_1, b_2, \\cdots, b_n b_1, b_2, \\cdots, b_n .","title":"Input"},{"location":"NOI/2019/Day1-C/#output","text":"For each test case, print a single integer \u2014 the maximal sum.","title":"Output"},{"location":"NOI/2019/Day1-C/#samples","text":"","title":"Samples"},{"location":"NOI/2019/Day1-C/#sample-1","text":"","title":"Sample 1"},{"location":"NOI/2019/Day1-C/#input_1","text":"5 1 1 1 7 7 3 2 1 4 1 2 1 4 2 5 2 1 4 5 5 8 4 2 1 7 2 7 6 4 1 1 5 8 3 2 4 2 6 9 3 1 7 7 5 4 1 6 6 6 5 9 1 9 5 3 9 1 4 2","title":"Input"},{"location":"NOI/2019/Day1-C/#output_1","text":"14 12 27 45 62","title":"Output"},{"location":"NOI/2019/Day1-C/#explanation","text":"For the first case, \\{c_i\\} = \\{d_i\\} = \\{1\\} \\{c_i\\} = \\{d_i\\} = \\{1\\} . For the second case, \\{c_i\\} = \\{1, 3\\} \\{c_i\\} = \\{1, 3\\} , \\{d_i\\} = \\{2, 3\\} \\{d_i\\} = \\{2, 3\\} . For the third case, \\{c_i\\} = \\{3, 4\\} \\{c_i\\} = \\{3, 4\\} , \\{d_i\\} = \\{3, 5\\} \\{d_i\\} = \\{3, 5\\} . For the fourth case, \\{c_i\\} = \\{d_i\\} = \\{2, 3, 4, 6\\} \\{c_i\\} = \\{d_i\\} = \\{2, 3, 4, 6\\} . For the fifth case, \\{c_i\\} = \\{2, 3, 4, 5, 6\\} \\{c_i\\} = \\{2, 3, 4, 5, 6\\} , \\{d_i\\} = \\{1, 2, 3, 4, 6\\} \\{d_i\\} = \\{1, 2, 3, 4, 6\\} .","title":"Explanation"},{"location":"NOI/2019/Day1-C/#constraints","text":"For all of the tests, T \\leq 10 T \\leq 10 , 1 \\leq \\sum{n} \\leq 10^6 1 \\leq \\sum{n} \\leq 10^6 , 1 \\leq L \\leq K \\leq n \\leq 2 \\times 10^5 1 \\leq L \\leq K \\leq n \\leq 2 \\times 10^5 , 1 \\leq a_i, b_i \\leq 10^9 1 \\leq a_i, b_i \\leq 10^9 . For partial scores, you can look up at the origin statement ( NOI/2019/Day1.pdf ).","title":"Constraints"},{"location":"NOI/2019/Day2-A/","text":"Time limit per test : \\texttt{2 s} \\texttt{2 s} Memory limit per test : \\texttt{128 MB} \\texttt{128 MB} You can submit this problem at: LibreOJ Input : jump.in Output : jump.out Luogu UOJ Description \u00b6 There are n n cities in the Kingdom of Flea, numbered from 1 1 to n n , and city 1 1 is the capital. All of the cities are located in a grid graph of size w \\times h w \\times h . Each city has an integer coordinate (x, y)\\,(1 \\leq x \\leq w, 1 \\leq y \\leq h) (x, y)\\,(1 \\leq x \\leq w, 1 \\leq y \\leq h) , and the coordinates of the cities are different from each other. There are m m bouncing devices in the Kingdom of Flea, numbered from 1 1 to m m . The i i -th device is located in city p_i p_i and with this device, a flea in city p_i p_i can jump to any city that satisfies L_i \\leq x \\leq R_i L_i \\leq x \\leq R_i , D_i \\leq y \\leq U_i D_i \\leq y \\leq U_i in t_i t_i time units. Since that the cities are quite far away from each other, so fleas always travel by the bouncing devices. Specifically, during a trip a flea will pass through several cities in turn, whose indices are a_0, a_1, \\cdots, a_k a_0, a_1, \\cdots, a_k , respectively; in this trip, the indices of bouncing devices used in turn are b_1, b_2, \\cdots, b_k b_1, b_2, \\cdots, b_k . Each cities can appear any number of times in the sequence \\{a_j\\} \\{a_j\\} , and each bouncing devices can appear any number of times in the sequence \\{b_j\\} \\{b_j\\} and for each j\\, (1 \\leq j \\leq k) j\\, (1 \\leq j \\leq k) , bouncing devices b_j b_j is located in the city a_{j\u22121} a_{j\u22121} and the flea can jump to city a_j a_j with the help of the bouncer. We call this a trip from city a_0 a_0 to city a_k a_k , which costs \\sum_{i=1}^{k}{t_{b_i}} \\sum_{i=1}^{k}{t_{b_i}} time units. Now the Flea King wants to know that for every city except the capital of the kingdom (city 1 1 ), how much time it will at least take to get to the city from the capital. Input \u00b6 The first line contains 4 4 integers n, m, w, h n, m, w, h . Each of the next n n lines contains 2 2 integers x_i, y_i x_i, y_i . Each of the next m m lines contains 6 6 integers p_i, t_i, L_i, R_i, D_i, U_i p_i, t_i, L_i, R_i, D_i, U_i , describing the information of the i i -th bouncing device. It's guaranteed that every city is reachable from the capital. Output \u00b6 You should print n - 1 n - 1 lines, the i i -th line contains the minimum time it needs to get to city i + 1 i + 1 from the capital. Samples \u00b6 Sample 1 \u00b6 Input \u00b6 5 3 5 5 1 1 3 1 4 1 2 2 3 3 1 123 1 5 1 5 1 50 1 5 1 1 3 10 2 2 2 2 Output \u00b6 50 50 60 123 Constraints \u00b6 1 \\leq n \\leq 70000 1 \\leq n \\leq 70000 1 \\leq m \\leq 150000 1 \\leq m \\leq 150000 1 \\leq w, h \\leq n 1 \\leq w, h \\leq n 1 \\leq t_i \\leq 10000 1 \\leq t_i \\leq 10000 For partial scores, you can look up at the origin statement ( NOI/2019/Day2.pdf ). Please note that the memory limit of this problem is 128 MB.","title":"Task A, Day 2"},{"location":"NOI/2019/Day2-A/#description","text":"There are n n cities in the Kingdom of Flea, numbered from 1 1 to n n , and city 1 1 is the capital. All of the cities are located in a grid graph of size w \\times h w \\times h . Each city has an integer coordinate (x, y)\\,(1 \\leq x \\leq w, 1 \\leq y \\leq h) (x, y)\\,(1 \\leq x \\leq w, 1 \\leq y \\leq h) , and the coordinates of the cities are different from each other. There are m m bouncing devices in the Kingdom of Flea, numbered from 1 1 to m m . The i i -th device is located in city p_i p_i and with this device, a flea in city p_i p_i can jump to any city that satisfies L_i \\leq x \\leq R_i L_i \\leq x \\leq R_i , D_i \\leq y \\leq U_i D_i \\leq y \\leq U_i in t_i t_i time units. Since that the cities are quite far away from each other, so fleas always travel by the bouncing devices. Specifically, during a trip a flea will pass through several cities in turn, whose indices are a_0, a_1, \\cdots, a_k a_0, a_1, \\cdots, a_k , respectively; in this trip, the indices of bouncing devices used in turn are b_1, b_2, \\cdots, b_k b_1, b_2, \\cdots, b_k . Each cities can appear any number of times in the sequence \\{a_j\\} \\{a_j\\} , and each bouncing devices can appear any number of times in the sequence \\{b_j\\} \\{b_j\\} and for each j\\, (1 \\leq j \\leq k) j\\, (1 \\leq j \\leq k) , bouncing devices b_j b_j is located in the city a_{j\u22121} a_{j\u22121} and the flea can jump to city a_j a_j with the help of the bouncer. We call this a trip from city a_0 a_0 to city a_k a_k , which costs \\sum_{i=1}^{k}{t_{b_i}} \\sum_{i=1}^{k}{t_{b_i}} time units. Now the Flea King wants to know that for every city except the capital of the kingdom (city 1 1 ), how much time it will at least take to get to the city from the capital.","title":"Description"},{"location":"NOI/2019/Day2-A/#input","text":"The first line contains 4 4 integers n, m, w, h n, m, w, h . Each of the next n n lines contains 2 2 integers x_i, y_i x_i, y_i . Each of the next m m lines contains 6 6 integers p_i, t_i, L_i, R_i, D_i, U_i p_i, t_i, L_i, R_i, D_i, U_i , describing the information of the i i -th bouncing device. It's guaranteed that every city is reachable from the capital.","title":"Input"},{"location":"NOI/2019/Day2-A/#output","text":"You should print n - 1 n - 1 lines, the i i -th line contains the minimum time it needs to get to city i + 1 i + 1 from the capital.","title":"Output"},{"location":"NOI/2019/Day2-A/#samples","text":"","title":"Samples"},{"location":"NOI/2019/Day2-A/#sample-1","text":"","title":"Sample 1"},{"location":"NOI/2019/Day2-A/#input_1","text":"5 3 5 5 1 1 3 1 4 1 2 2 3 3 1 123 1 5 1 5 1 50 1 5 1 1 3 10 2 2 2 2","title":"Input"},{"location":"NOI/2019/Day2-A/#output_1","text":"50 50 60 123","title":"Output"},{"location":"NOI/2019/Day2-A/#constraints","text":"1 \\leq n \\leq 70000 1 \\leq n \\leq 70000 1 \\leq m \\leq 150000 1 \\leq m \\leq 150000 1 \\leq w, h \\leq n 1 \\leq w, h \\leq n 1 \\leq t_i \\leq 10000 1 \\leq t_i \\leq 10000 For partial scores, you can look up at the origin statement ( NOI/2019/Day2.pdf ). Please note that the memory limit of this problem is 128 MB.","title":"Constraints"},{"location":"NOI/2019/Day2-B/","text":"Time limit per test : \\texttt{4 s} \\texttt{4 s} Memory limit per test : \\texttt{512 MB} \\texttt{512 MB} You can submit this problem at: LibreOJ Input : landlords.in Output : landlords.out Luogu UOJ Description \u00b6 Alice and Bob are playing card games, but Alice found that she can never win Bob, so she plans to cheat in the shuffling session. There are n n cards in total, numbered from 1 1 to n n from top to bottom. The card with index i i has a score of f(i) f(i) . In this problem, f(i) = i f(i) = i or f(i) = i^2 f(i) = i^2 always holds. The whole shuffling session can be devided into m m rounds. During the i i -th round: Alice will take A_i A_i cards from the top, then all the cards are divided into 2 piles: the first contains A_i A_i cards from the top, the second contains the remaining n - A_i n - A_i cards. In particular, when A_i = 0 A_i = 0 or A_i = n A_i = n , one of the piles will be empty. Then Alice will merge the two piles in the following way. When there are X X cards left in the first pile and Y Y in the second, she will take the card at the bottom of the first pile with the probability of \\frac{X}{X + Y} \\frac{X}{X + Y} , and put it on the top of the new pile; otherwise she will take the card at the bottom of the second pile and put it on the top of the new pile. Since the shuffling session is random, Alice can't know which card it is at a certain position. But Alice wants to know the expected score of the card at a certain position after m m rounds of shuffling. Input \u00b6 The first line contains 3 3 integers n, m, \\text{type} n, m, \\text{type} . When \\text{type} = 1 \\text{type} = 1 , f(i) = i f(i) = i , otherwise f(i) = i^2 f(i) = i^2 . The second line contains m m integers A_1, A_2, \\cdots, A_m A_1, A_2, \\cdots, A_m . The third line contains a single integer Q Q \u2014 the number of queries. Each of the next Q Q lines contains a single integer c_i c_i . Output \u00b6 You should print Q Q lines, the i i -th line contains the expected score of the c_i c_i -th card from top to bottom. You should print the answer module 998244353 998244353 , that is, if the answer is \\frac{a}{b} \\frac{a}{b} , where (a, b) = 1 (a, b) = 1 , you should print an integer x x such that bx \\equiv a \\pmod{998244353} bx \\equiv a \\pmod{998244353} and 0 \\leq x < 998244353 0 \\leq x < 998244353 . One can prove that such x x is unique. Samples \u00b6 Sample 1 \u00b6 Input \u00b6 4 1 1 3 1 1 Output \u00b6 249561090 Explanation \u00b6 After shuffling, the cards will become: \\{1, 2, 3, 4\\} \\{1, 2, 3, 4\\} from top to bottom with the probability of \\frac{1}{4} \\frac{1}{4} \\{1, 2, 4, 3\\} \\{1, 2, 4, 3\\} from top to bottom with the probability of \\frac{1}{4} \\frac{1}{4} \\{1, 4, 2, 3\\} \\{1, 4, 2, 3\\} from top to bottom with the probability of \\frac{1}{4} \\frac{1}{4} \\{4, 1, 2, 3\\} \\{4, 1, 2, 3\\} from top to bottom with the probability of \\frac{1}{4} \\frac{1}{4} So the expected score of the first place is \\frac{1}{4}(1 + 1 + 1 + 4) = \\frac{7}{4} \\frac{1}{4}(1 + 1 + 1 + 4) = \\frac{7}{4} . If you still have no idea how the it shuffles, some pictures in the Chinese statement ( 2019-NOI-Day2.pdf ) will show you how to get \\{1, 4, 2, 3\\} \\{1, 4, 2, 3\\} . Constraints \u00b6 3 \\leq n \\leq 10^7 3 \\leq n \\leq 10^7 1 \\leq m, Q \\leq 5 \\times 10^5 1 \\leq m, Q \\leq 5 \\times 10^5 0 \\leq A_i \\leq n 0 \\leq A_i \\leq n \\text{type} \\in \\{1, 2\\} \\text{type} \\in \\{1, 2\\} For partial scores, you can look up at the origin statement ( NOI/2019/Day2.pdf ).","title":"Task B, Day 2"},{"location":"NOI/2019/Day2-B/#description","text":"Alice and Bob are playing card games, but Alice found that she can never win Bob, so she plans to cheat in the shuffling session. There are n n cards in total, numbered from 1 1 to n n from top to bottom. The card with index i i has a score of f(i) f(i) . In this problem, f(i) = i f(i) = i or f(i) = i^2 f(i) = i^2 always holds. The whole shuffling session can be devided into m m rounds. During the i i -th round: Alice will take A_i A_i cards from the top, then all the cards are divided into 2 piles: the first contains A_i A_i cards from the top, the second contains the remaining n - A_i n - A_i cards. In particular, when A_i = 0 A_i = 0 or A_i = n A_i = n , one of the piles will be empty. Then Alice will merge the two piles in the following way. When there are X X cards left in the first pile and Y Y in the second, she will take the card at the bottom of the first pile with the probability of \\frac{X}{X + Y} \\frac{X}{X + Y} , and put it on the top of the new pile; otherwise she will take the card at the bottom of the second pile and put it on the top of the new pile. Since the shuffling session is random, Alice can't know which card it is at a certain position. But Alice wants to know the expected score of the card at a certain position after m m rounds of shuffling.","title":"Description"},{"location":"NOI/2019/Day2-B/#input","text":"The first line contains 3 3 integers n, m, \\text{type} n, m, \\text{type} . When \\text{type} = 1 \\text{type} = 1 , f(i) = i f(i) = i , otherwise f(i) = i^2 f(i) = i^2 . The second line contains m m integers A_1, A_2, \\cdots, A_m A_1, A_2, \\cdots, A_m . The third line contains a single integer Q Q \u2014 the number of queries. Each of the next Q Q lines contains a single integer c_i c_i .","title":"Input"},{"location":"NOI/2019/Day2-B/#output","text":"You should print Q Q lines, the i i -th line contains the expected score of the c_i c_i -th card from top to bottom. You should print the answer module 998244353 998244353 , that is, if the answer is \\frac{a}{b} \\frac{a}{b} , where (a, b) = 1 (a, b) = 1 , you should print an integer x x such that bx \\equiv a \\pmod{998244353} bx \\equiv a \\pmod{998244353} and 0 \\leq x < 998244353 0 \\leq x < 998244353 . One can prove that such x x is unique.","title":"Output"},{"location":"NOI/2019/Day2-B/#samples","text":"","title":"Samples"},{"location":"NOI/2019/Day2-B/#sample-1","text":"","title":"Sample 1"},{"location":"NOI/2019/Day2-B/#input_1","text":"4 1 1 3 1 1","title":"Input"},{"location":"NOI/2019/Day2-B/#output_1","text":"249561090","title":"Output"},{"location":"NOI/2019/Day2-B/#explanation","text":"After shuffling, the cards will become: \\{1, 2, 3, 4\\} \\{1, 2, 3, 4\\} from top to bottom with the probability of \\frac{1}{4} \\frac{1}{4} \\{1, 2, 4, 3\\} \\{1, 2, 4, 3\\} from top to bottom with the probability of \\frac{1}{4} \\frac{1}{4} \\{1, 4, 2, 3\\} \\{1, 4, 2, 3\\} from top to bottom with the probability of \\frac{1}{4} \\frac{1}{4} \\{4, 1, 2, 3\\} \\{4, 1, 2, 3\\} from top to bottom with the probability of \\frac{1}{4} \\frac{1}{4} So the expected score of the first place is \\frac{1}{4}(1 + 1 + 1 + 4) = \\frac{7}{4} \\frac{1}{4}(1 + 1 + 1 + 4) = \\frac{7}{4} . If you still have no idea how the it shuffles, some pictures in the Chinese statement ( 2019-NOI-Day2.pdf ) will show you how to get \\{1, 4, 2, 3\\} \\{1, 4, 2, 3\\} .","title":"Explanation"},{"location":"NOI/2019/Day2-B/#constraints","text":"3 \\leq n \\leq 10^7 3 \\leq n \\leq 10^7 1 \\leq m, Q \\leq 5 \\times 10^5 1 \\leq m, Q \\leq 5 \\times 10^5 0 \\leq A_i \\leq n 0 \\leq A_i \\leq n \\text{type} \\in \\{1, 2\\} \\text{type} \\in \\{1, 2\\} For partial scores, you can look up at the origin statement ( NOI/2019/Day2.pdf ).","title":"Constraints"},{"location":"NOI/2019/Day2-C/","text":"Time limit per test : \\texttt{2 s} \\texttt{2 s} Memory limit per test : \\texttt{512 MB} \\texttt{512 MB} You can submit this problem at: LibreOJ Only C++ is available. UOJ Both C/C++ and Pascal are available. This is an interactive problem. Description \u00b6 The underground palace consists of N N caves and M M roads between them, which can be represented as an undirected simple graph of N N vertices and M M edges. The caves are numbered from 0 0 to n - 1 n - 1 , and you do NOT know where the roads are. There is a light in each cave, all of them are either off or on. Initially, all the lights are off, and the status of the lights can be changed only by the mysterious machine in your hand. Specifically, it can perform the following 4 4 operations: For a certain x x , it will change the status of the lights in cave x x and the caves that directly connected to cave x x . That is, turn on the light if it's off, and turn off the light if it's on. For a certain x x , it will show you the current status of the lights in cave x x . For certain x, y x, y , it will record an edge between cave x x and cave y y . For a certain x x , it will tell whether all the roads connected to cave x x are recorded. The machine can only deal with one operation at the same time, and the number of uses for each operation is limited, L_m, L_q, M, L_c L_m, L_q, M, L_c respectively. Your task is to write a program to find all the M M edges correctly. Interaction Protocol \u00b6 You should implement the following function: void explore ( int N , int M ); \\texttt{N} \\texttt{N} : the number of caves. \\texttt{M} \\texttt{M} : the number of roads. This function is called exactly once for each test case. Your program can call the following functions: void modify ( int x ); \\texttt{x} \\texttt{x} : The index of the cave you want to operate on. You should guarantee that 0 \\leq x < N 0 \\leq x < N . You cannot call this function more than L_m L_m times for each test case. This function will perform the first operation on cave x x and return nothing. int query ( int x ); \\texttt{x} \\texttt{x} : The index of the cave you want to operate on. You should guarantee that 0 \\leq x < N 0 \\leq x < N . You cannot call this function more than L_q L_q times for each test case. This function will perform the second operation on cave x x . This function will return 1 if the light in cave x x in on, and 0 otherwise. void report ( int x , int y ); \\texttt{x}, \\texttt{y} \\texttt{x}, \\texttt{y} : The indeies of the caves you want to operate on. You should guarantee that 0 \\leq x, y < N 0 \\leq x, y < N and x \\neq y x \\neq y . You cannot call this function more than M M times for each test case. This function will record an edge between cave x x and cave y y , and return nothing. int check ( int x ); \\texttt{x} \\texttt{x} : The index of the cave you want to operate on. You should guarantee that 0 \\leq x < N 0 \\leq x < N . You cannot call this function more than L_c L_c times for each test case. This function will perform the fourth operation on cave x x . This function will return 1 if all the roads connected to cave x x are recorded, and 0 otherwise. In this problem, the grader is NOT adaptive. This means that the graph is fixed at the beginning of the running of the grader and it does not depend on the operations performed by your solution. It is guaranteed that grader will use no more than \\texttt{1 s} \\texttt{1 s} of time and no more than \\texttt{128 MB} \\texttt{128 MB} of memory. Sample grader \u00b6 You are given a sample grader ( grader.c/cpp for C/C++ and graderhelperlib.pas for Pascal ) together with the sample tests. In order to test the samples, you need to compile the grader and your code into a single executable file. The executable file will get input in the following format: The first line contains 3 3 integers L_m, L_q, L_c L_m, L_q, L_c . The second line contains 2 2 integers N, M N, M . Each of the next M M lines contains 2 2 integers x, y x, y , refers to a road between cave x x and cave y y . If your program is judged as Accepted , the sample grader prints Correct and the number of times you call each function. Otherwise, it will print what's wrong with your solution. Sample \u00b6 Assume that the input is as follows: 100 200 300 3 2 0 1 1 2 The first line shows that you can call modify(x) for no more than 100 100 times, query(x) for no more than 200 200 times, and check(x) for no more than 300 300 times, respectively. The second line shows that N = 3 N = 3 and M = 2 M = 2 . A possible way of interaction is listed below: Your Program Grader Comment call explore(3, 2) Test Begins. call modify(0) Perform operate 1 on cave 0 0 . call query(2) return 0 0 . The light in cave 2 2 is off currently. call report(0, 1) Find a road (0, 1) (0, 1) and record it. call check(0) return 1 1 . All the roads connected to cave 0 0 have been recorded. call report(2, 1) Find a road (2, 1) (2, 1) and record it. return Print Correct . You solve the problem correctly. Constraints \u00b6 3 \\leq N \\leq 200000 3 \\leq N \\leq 200000 2 \\leq M \\leq 300000 2 \\leq M \\leq 300000 More constraints are attached to each test, which can be found in the origin statement ( NOI/2019/Day2.pdf ). Note: the lowest digit of N N may help you get partial scores easilier.","title":"Task C, Day 2"},{"location":"NOI/2019/Day2-C/#description","text":"The underground palace consists of N N caves and M M roads between them, which can be represented as an undirected simple graph of N N vertices and M M edges. The caves are numbered from 0 0 to n - 1 n - 1 , and you do NOT know where the roads are. There is a light in each cave, all of them are either off or on. Initially, all the lights are off, and the status of the lights can be changed only by the mysterious machine in your hand. Specifically, it can perform the following 4 4 operations: For a certain x x , it will change the status of the lights in cave x x and the caves that directly connected to cave x x . That is, turn on the light if it's off, and turn off the light if it's on. For a certain x x , it will show you the current status of the lights in cave x x . For certain x, y x, y , it will record an edge between cave x x and cave y y . For a certain x x , it will tell whether all the roads connected to cave x x are recorded. The machine can only deal with one operation at the same time, and the number of uses for each operation is limited, L_m, L_q, M, L_c L_m, L_q, M, L_c respectively. Your task is to write a program to find all the M M edges correctly.","title":"Description"},{"location":"NOI/2019/Day2-C/#interaction-protocol","text":"You should implement the following function: void explore ( int N , int M ); \\texttt{N} \\texttt{N} : the number of caves. \\texttt{M} \\texttt{M} : the number of roads. This function is called exactly once for each test case. Your program can call the following functions: void modify ( int x ); \\texttt{x} \\texttt{x} : The index of the cave you want to operate on. You should guarantee that 0 \\leq x < N 0 \\leq x < N . You cannot call this function more than L_m L_m times for each test case. This function will perform the first operation on cave x x and return nothing. int query ( int x ); \\texttt{x} \\texttt{x} : The index of the cave you want to operate on. You should guarantee that 0 \\leq x < N 0 \\leq x < N . You cannot call this function more than L_q L_q times for each test case. This function will perform the second operation on cave x x . This function will return 1 if the light in cave x x in on, and 0 otherwise. void report ( int x , int y ); \\texttt{x}, \\texttt{y} \\texttt{x}, \\texttt{y} : The indeies of the caves you want to operate on. You should guarantee that 0 \\leq x, y < N 0 \\leq x, y < N and x \\neq y x \\neq y . You cannot call this function more than M M times for each test case. This function will record an edge between cave x x and cave y y , and return nothing. int check ( int x ); \\texttt{x} \\texttt{x} : The index of the cave you want to operate on. You should guarantee that 0 \\leq x < N 0 \\leq x < N . You cannot call this function more than L_c L_c times for each test case. This function will perform the fourth operation on cave x x . This function will return 1 if all the roads connected to cave x x are recorded, and 0 otherwise. In this problem, the grader is NOT adaptive. This means that the graph is fixed at the beginning of the running of the grader and it does not depend on the operations performed by your solution. It is guaranteed that grader will use no more than \\texttt{1 s} \\texttt{1 s} of time and no more than \\texttt{128 MB} \\texttt{128 MB} of memory.","title":"Interaction Protocol"},{"location":"NOI/2019/Day2-C/#sample-grader","text":"You are given a sample grader ( grader.c/cpp for C/C++ and graderhelperlib.pas for Pascal ) together with the sample tests. In order to test the samples, you need to compile the grader and your code into a single executable file. The executable file will get input in the following format: The first line contains 3 3 integers L_m, L_q, L_c L_m, L_q, L_c . The second line contains 2 2 integers N, M N, M . Each of the next M M lines contains 2 2 integers x, y x, y , refers to a road between cave x x and cave y y . If your program is judged as Accepted , the sample grader prints Correct and the number of times you call each function. Otherwise, it will print what's wrong with your solution.","title":"Sample grader"},{"location":"NOI/2019/Day2-C/#sample","text":"Assume that the input is as follows: 100 200 300 3 2 0 1 1 2 The first line shows that you can call modify(x) for no more than 100 100 times, query(x) for no more than 200 200 times, and check(x) for no more than 300 300 times, respectively. The second line shows that N = 3 N = 3 and M = 2 M = 2 . A possible way of interaction is listed below: Your Program Grader Comment call explore(3, 2) Test Begins. call modify(0) Perform operate 1 on cave 0 0 . call query(2) return 0 0 . The light in cave 2 2 is off currently. call report(0, 1) Find a road (0, 1) (0, 1) and record it. call check(0) return 1 1 . All the roads connected to cave 0 0 have been recorded. call report(2, 1) Find a road (2, 1) (2, 1) and record it. return Print Correct . You solve the problem correctly.","title":"Sample"},{"location":"NOI/2019/Day2-C/#constraints","text":"3 \\leq N \\leq 200000 3 \\leq N \\leq 200000 2 \\leq M \\leq 300000 2 \\leq M \\leq 300000 More constraints are attached to each test, which can be found in the origin statement ( NOI/2019/Day2.pdf ). Note: the lowest digit of N N may help you get partial scores easilier.","title":"Constraints"},{"location":"NOI/2020/Day1-A/","text":"Time limit per test : \\texttt{2 s} \\texttt{2 s} Memory limit per test : \\texttt{512 MB} \\texttt{512 MB} You can submit this problem at: LibreOJ Input: delicacy.in Output: delicacy.out Luogu UOJ Description \u00b6 After repelling the invasion of the Legion and more than ten years of recuperation, the Elven Kingdom located on the continent of Bzeroth, has become a thriving paradise again, attracting tourists throughout the world. Little W is a famous foodie who has traveled all over the world, and now he also came to this kingdom. There are n n cities in the kingdom, numbered from 1 1 to n n . The food in city i i can provide Little W with a pleasure points of c_i c_i . The cities of the kingdom are connected by m m directed roads, numbered from 1 1 to m m . The i i -th road starts from city u_i u_i and ends at city v_i v_i , and it takes w_i w_i days to travel along it. In other words, if Little W travels along road i i from city u_i u_i on the d d -th day, he will reach the city v_i v_i on the (d+w_i) (d+w_i) -th day. Little W plans a travel of T T days in the kingdom, more specifically: he will depart from city 1 1 on Day 0 0 , and finally return to city 1 1 on Day T T . Since Little W is a foodie, whenever he arrives in a city (including the city 1 1 on Day 0 0 and Day T T ), he will taste the food of the city and get the pleasure points it provides. If Little W arrives in the same city multiple times, he will get the pleasure points multiple times. Note that W CANNOT stop in any city during the trip, that is, when he arrives in a city but his trip doesn't finish, he must depart from that city at the same day. In addition, the Elven Kingdom will hold k k food festivals at different times . Specifically, the i i -th food festival will be held in city x_i x_i on the t_i t_i -th day. If Little W happens to be in city x_i x_i on Day t_i t_i , he will get an extra pleasure points of y_i y_i when he tastes the food in city x_i x_i . Now Little W would like to ask you, the reception envoy of the Elven Kingdom, to help him calculate the maximum of the sum of pleasure points he can get during his travel. Input \u00b6 The first line contains 4 4 integers n (1 \\leq n \\leq 50) n (1 \\leq n \\leq 50) , m (n \\leq m \\leq 501) m (n \\leq m \\leq 501) , T (1 \\leq T \\leq 10^9) T (1 \\leq T \\leq 10^9) and k (0 \\leq k \\leq 200) k (0 \\leq k \\leq 200) , indicating the number of cities, roads, days of travel and food festival respectively. The second line contains n n integers c_i (1 \\leq c_i \\leq 52501) c_i (1 \\leq c_i \\leq 52501) , indicating the pleasure point that the food of each city can provide. Each of the next m m lines contains 3 3 integers u_i, v_i, w_i (u_i \\neq v_i, 1 \\leq u_i, v_i \\leq n, 1 \\leq w_i \\leq 5) u_i, v_i, w_i (u_i \\neq v_i, 1 \\leq u_i, v_i \\leq n, 1 \\leq w_i \\leq 5) , describing a road. Each of the next k k lines contains 3 3 integers t_i, x_i, y_i (1 \\leq t_i \\leq T, 1 \\leq x_i \\leq n, 1 \\leq y_i \\leq 10^9) t_i, x_i, y_i (1 \\leq t_i \\leq T, 1 \\leq x_i \\leq n, 1 \\leq y_i \\leq 10^9) , describing a food festival. It's guaranteed that: For each city, there are at least 1 1 road start from it. All the t_i t_i are pairwise distinct. Output \u00b6 Print a single integer \u2014 the maximal pleasure points he can get. If Little W can't return city 1 1 on Day T T , print -1 . Samples \u00b6 Sample 1 \u00b6 Input \u00b6 3 4 11 0 1 3 4 1 2 1 2 1 3 2 3 2 3 1 4 Output \u00b6 13 Explanation \u00b6 As the picture shown above, the optimal plan is 1 \\rightarrow 2 \\rightarrow 1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 1 1 \\rightarrow 2 \\rightarrow 1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 1 . On Day 0 0 , Little W start his travel from city 1 1 , get 1 1 pleasure point and sets off for city 2 2 . On Day 1 1 , Little W arrives at city 2 2 , get 3 3 pleasure points and sets off for city 1 1 . On Day 4 4 , Little W arrives at city 1 1 , get 1 1 pleasure point and sets off for city 2 2 . On Day 5 5 , Little W arrives at city 2 2 , get 3 3 pleasure points and sets off for city 3 3 . On Day 7 7 , Little W arrives at city 3 3 , get 4 4 pleasure points and sets off for city 1 1 . On Day 11 11 , Little W arrives at city 1 1 , get 1 1 pleasure point and end his travel. Little W get 13 13 pleasure points in total. So the minimal anxiety is 94 94 . Sample 2 \u00b6 Input \u00b6 4 8 16 3 3 1 2 4 1 2 1 1 3 1 1 3 2 3 4 3 2 3 2 3 2 1 4 2 1 4 1 5 3 3 5 1 2 5 5 4 20 Output \u00b6 39 Explanation \u00b6 The optimal plan is 1 \\rightarrow 3 \\rightarrow 4 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4 \\rightarrow 1 1 \\rightarrow 3 \\rightarrow 4 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4 \\rightarrow 1 . Sample 3 \u00b6 Please check the other samples at NOI/2020/Day1-samples.zip . Subtasks \u00b6 For partial scores, you can look up at the origin statement ( NOI/2020/Day1.pdf ).","title":"Task A, Day 1"},{"location":"NOI/2020/Day1-A/#description","text":"After repelling the invasion of the Legion and more than ten years of recuperation, the Elven Kingdom located on the continent of Bzeroth, has become a thriving paradise again, attracting tourists throughout the world. Little W is a famous foodie who has traveled all over the world, and now he also came to this kingdom. There are n n cities in the kingdom, numbered from 1 1 to n n . The food in city i i can provide Little W with a pleasure points of c_i c_i . The cities of the kingdom are connected by m m directed roads, numbered from 1 1 to m m . The i i -th road starts from city u_i u_i and ends at city v_i v_i , and it takes w_i w_i days to travel along it. In other words, if Little W travels along road i i from city u_i u_i on the d d -th day, he will reach the city v_i v_i on the (d+w_i) (d+w_i) -th day. Little W plans a travel of T T days in the kingdom, more specifically: he will depart from city 1 1 on Day 0 0 , and finally return to city 1 1 on Day T T . Since Little W is a foodie, whenever he arrives in a city (including the city 1 1 on Day 0 0 and Day T T ), he will taste the food of the city and get the pleasure points it provides. If Little W arrives in the same city multiple times, he will get the pleasure points multiple times. Note that W CANNOT stop in any city during the trip, that is, when he arrives in a city but his trip doesn't finish, he must depart from that city at the same day. In addition, the Elven Kingdom will hold k k food festivals at different times . Specifically, the i i -th food festival will be held in city x_i x_i on the t_i t_i -th day. If Little W happens to be in city x_i x_i on Day t_i t_i , he will get an extra pleasure points of y_i y_i when he tastes the food in city x_i x_i . Now Little W would like to ask you, the reception envoy of the Elven Kingdom, to help him calculate the maximum of the sum of pleasure points he can get during his travel.","title":"Description"},{"location":"NOI/2020/Day1-A/#input","text":"The first line contains 4 4 integers n (1 \\leq n \\leq 50) n (1 \\leq n \\leq 50) , m (n \\leq m \\leq 501) m (n \\leq m \\leq 501) , T (1 \\leq T \\leq 10^9) T (1 \\leq T \\leq 10^9) and k (0 \\leq k \\leq 200) k (0 \\leq k \\leq 200) , indicating the number of cities, roads, days of travel and food festival respectively. The second line contains n n integers c_i (1 \\leq c_i \\leq 52501) c_i (1 \\leq c_i \\leq 52501) , indicating the pleasure point that the food of each city can provide. Each of the next m m lines contains 3 3 integers u_i, v_i, w_i (u_i \\neq v_i, 1 \\leq u_i, v_i \\leq n, 1 \\leq w_i \\leq 5) u_i, v_i, w_i (u_i \\neq v_i, 1 \\leq u_i, v_i \\leq n, 1 \\leq w_i \\leq 5) , describing a road. Each of the next k k lines contains 3 3 integers t_i, x_i, y_i (1 \\leq t_i \\leq T, 1 \\leq x_i \\leq n, 1 \\leq y_i \\leq 10^9) t_i, x_i, y_i (1 \\leq t_i \\leq T, 1 \\leq x_i \\leq n, 1 \\leq y_i \\leq 10^9) , describing a food festival. It's guaranteed that: For each city, there are at least 1 1 road start from it. All the t_i t_i are pairwise distinct.","title":"Input"},{"location":"NOI/2020/Day1-A/#output","text":"Print a single integer \u2014 the maximal pleasure points he can get. If Little W can't return city 1 1 on Day T T , print -1 .","title":"Output"},{"location":"NOI/2020/Day1-A/#samples","text":"","title":"Samples"},{"location":"NOI/2020/Day1-A/#sample-1","text":"","title":"Sample 1"},{"location":"NOI/2020/Day1-A/#input_1","text":"3 4 11 0 1 3 4 1 2 1 2 1 3 2 3 2 3 1 4","title":"Input"},{"location":"NOI/2020/Day1-A/#output_1","text":"13","title":"Output"},{"location":"NOI/2020/Day1-A/#explanation","text":"As the picture shown above, the optimal plan is 1 \\rightarrow 2 \\rightarrow 1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 1 1 \\rightarrow 2 \\rightarrow 1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 1 . On Day 0 0 , Little W start his travel from city 1 1 , get 1 1 pleasure point and sets off for city 2 2 . On Day 1 1 , Little W arrives at city 2 2 , get 3 3 pleasure points and sets off for city 1 1 . On Day 4 4 , Little W arrives at city 1 1 , get 1 1 pleasure point and sets off for city 2 2 . On Day 5 5 , Little W arrives at city 2 2 , get 3 3 pleasure points and sets off for city 3 3 . On Day 7 7 , Little W arrives at city 3 3 , get 4 4 pleasure points and sets off for city 1 1 . On Day 11 11 , Little W arrives at city 1 1 , get 1 1 pleasure point and end his travel. Little W get 13 13 pleasure points in total. So the minimal anxiety is 94 94 .","title":"Explanation"},{"location":"NOI/2020/Day1-A/#sample-2","text":"","title":"Sample 2"},{"location":"NOI/2020/Day1-A/#input_2","text":"4 8 16 3 3 1 2 4 1 2 1 1 3 1 1 3 2 3 4 3 2 3 2 3 2 1 4 2 1 4 1 5 3 3 5 1 2 5 5 4 20","title":"Input"},{"location":"NOI/2020/Day1-A/#output_2","text":"39","title":"Output"},{"location":"NOI/2020/Day1-A/#explanation_1","text":"The optimal plan is 1 \\rightarrow 3 \\rightarrow 4 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4 \\rightarrow 1 1 \\rightarrow 3 \\rightarrow 4 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4 \\rightarrow 1 .","title":"Explanation"},{"location":"NOI/2020/Day1-A/#sample-3","text":"Please check the other samples at NOI/2020/Day1-samples.zip .","title":"Sample 3"},{"location":"NOI/2020/Day1-A/#subtasks","text":"For partial scores, you can look up at the origin statement ( NOI/2020/Day1.pdf ).","title":"Subtasks"}]}